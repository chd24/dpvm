/* elflinux class, addSection method implementation, T20.362-T20.363; $DVS:time$ */

#include "../../../../../lib/stdlib/stdlib.dpvmake"
#include "../../../../../lib/utils/utils.dpvmake"
#include "elflinux.dpvmake"

int header[] = {
	/* ELF header */
	0x00010102464c457f, 0x0000000000000000, 0x00000001003e0002, 0x0000000000400080,
	0x0000000000000040, 0x0000000000000000, 0x0038004000000000, 0x0000000000000001,
	/* program header */
	0x0000000700000001, 0x0000000000000080, 0x0000000000400080, 0x0000000000000000,
	0x0000000000000040, 0x0000000000000040, 0x0000000000001000, 0x0000000000000000,
	/* start code:
		use64

		; run-time objects allocation
		lea r8, [rsp-90000h]		; thread
		lea r10,[r8+0xb0]		; task
		lea r11,[r10+0xb0]		; stack

		; thread object initialization
		lea rax,[r8+10000h]		; thread links
		mov [r8],rax
		mov [rax],r11			; thread link to stack
		mov [rax+18h],r10		; thread link to task
		lea rax,[r8+20000h]		; thread ints
		mov [r8+8],rax

		; task object initialization
		lea rax,[r8+30000h]		; task links
		mov [r10],rax
		lea rax,[r8+40000h]		; task ints
		mov [r10+8h],rax
		mov qword [rax], 0		; task flags

		; stack object initialization
		lea rdi,[r8+50000h]		; links stack
		mov [r11],rdi
		lea rsi,[r8+60000h]		; ints stack
		mov [r11+8],rsi
		pop rax				; argc
		mov [rsi],rax			; push argc to ints stack
		add rsi,8
		lea rdx,[r8+70000h]		; floats stack
		mov [r11+10h],rdx
		lea rcx,[r8+80000h]		; chars stack
		mov [r11+18h],rcx

		; call main function
		mov rsp,r8
		nop
		nop
		mov rax, 123456789abcdefh	; entry point
		call rax			; call

		; exit the program
		push 60				; syscall exit
		pop rax
		mov rdi,[rsi-8]			; int return value as exit parameter
		db 0fh, 05h			; syscall
	*/
	0xfff7000024848d4c, 0x4d000000b0908d4d, 0x8d49000000b09a8d, 0x0089490001000080,
	0x491850894c18894c, 0x894900020000808d, 0x030000808d490840, 0x00808d4902894900,
	0x4808428949000400, 0x8d490000000000c7, 0x3b894900050000b8, 0x4900060000b08d49,
	0x4806894858087389, 0x0000908d4908c683, 0x8d49105389490007, 0x4b89490008000088,
	0xb8489090c4894c18, 0x0123456789abcdef, 0x7e8b48583c6ad0ff, 0x0000000000050ff8
};

int sectionStart		= 0x80;
int sectionFlagsPos		= 0x08;
int sectionFlagsOffset		= 32;
int sectionLengthFilePos	= 0x0c;
int sectionLengthMemPos		= 0x0d;
int entryPointPos		= 0x21;

(volatile stateful any elflinuxObj, const char data[], int flags) -> (const char error[]) addSection = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "addSection");
	if (err.csize) return err;

	if (!impl.data.archSet)
		return mkError("arch is not set", "addSection");

	if (!impl.data.outputFileSet)
		return mkError("output file is not set", "addSection");

	if (!impl.data.outputFilePos)
		impl.data.outputFilePos = header.isize << 3;

	writep({}, {}, impl.data.outputFile, data, impl.data.outputFilePos);
	impl.data.outputFilePos += data.csize;

	if (flags == -1) {
		int h[];
		objcopyto(h, header);
		h[sectionFlagsPos] &= ~(-1 << sectionFlagsOffset);
		h[sectionFlagsPos] |= impl.data.sectionFlags << sectionFlagsOffset;
		h[sectionLengthFilePos] = impl.data.outputFilePos - sectionStart;
		h[sectionLengthMemPos] = impl.data.outputFilePos - sectionStart;
		h[entryPointPos] = impl.data.entryPoint;
		writep({}, {}, impl.data.outputFile, ints2chars(h, 0, h.isize), 0);
	} else
		impl.data.sectionFlags |= flags;

	return "";
};
