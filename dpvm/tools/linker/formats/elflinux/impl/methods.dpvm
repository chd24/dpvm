/* elflinux class, methods implementation, T20.360-T20.361; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.2, T19.354-T20.056 */

#include "../../../../../tools/registry/registry.dpvmake"
#include "elflinux.dpvmake"
#include "version.dpvmh"

int registryMask = REGISTRY_COMPILER;	/* mask of registry applications used by elflinux class */

(volatile stateful any elflinuxObj) -> (const char error[], int flags) getFlags = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any elflinuxObj, int flags) -> (const char error[]) setFlags = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any elflinuxObj, const stateful any registry) -> (const char error[]) setRegistry = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(volatile stateful any elflinuxObj, int entryPoint) -> (const char error[]) setEntryPoint = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "setEntryPoint");
	if (err.csize) return err;

	impl.data.entryPoint = entryPoint;
	return "";
};

(volatile stateful any elflinuxObj, const char arch[]) -> (const char error[]) setArch = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "setArch");
	if (err.csize) return err;

	impl.data.arch = arch;
	impl.data.archSet = 1;
	return "";
};

(volatile stateful any elflinuxObj, const char outputFile[]) -> (const char error[]) setOutputFile = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "setOutputFile");
	if (err.csize) return err;

	impl.data.outputFile = outputFile;
	impl.data.outputFileSet = 1;
	return "";
};

(volatile stateful any elflinuxObj, const char data[], int flags) -> (const char error[]) addSection = {
	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "addSection");
	if (err.csize) return err;

	return mkError("not inplemented", "addSection");
};

(volatile stateful any elflinuxObj) -> (const char error[]) finish = {
 	elflinuxImpl impl;
	char err[] = convertObjToImpl(impl, elflinuxObj, "finish");
	if (err.csize) return err;

	return mkError("not inplemented", "finish");
};

elflinuxMethods elflinuxMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setEntryPoint,
	setArch,
	setOutputFile,
	setRegistry,
	dump,
	addSection,
	finish
};
