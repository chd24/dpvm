/* split schema to chains; T16.576-T16.615; $DVS:time$ */

#include "graphs.dpvmake"

int startreg		= 0x4000000000000000;
int nregs		= 14;

int edgeweight		= 3; /* weight of single edge */
int vertexweight	= 1; /* weight of not-end vertex in edges chain */

(volatile stateful schema s) -> () {
	gate g = s.base;
	g.depth = -1;
	g.depthend = 0;

	int nedges;

	for (g = g.next; g.depth >= 0; g = g.next) {
		g.stackpos0 = -1, g.stackpos1 = -1;
		if (g.edgesmask & 1) nedges = nedges + 1;
		if (g.edgesmask & 2) nedges = nedges + 1;
	}

	int i;
	for (i = 0; i < s.inputs.lsize; i = i + 1) {
		g = s.inputs[i];
		g.stackpos0 = i;
		if (g.edgesmask & 0xC) nedges = nedges - 1;
	}

	for (i = 0; i < s.outputs.lsize; i = i + 1) {
		g = s.outputs[i];
		if (s.outright[i])
			g.stackpos1 = s.startout + i;
		else
			g.stackpos0 = s.startout + i;
	}

	int chainno = startreg;
	int startmem = s.startout + s.outputs.lsize;
	if (startmem < s.inputs.lsize)
		startmem = s.inputs.lsize;

	int regs[];
	int mems[];

	while (nedges) {
		for (g = s.base.next; g.depth >= 0; g = g.next) {
			g.depth = g.prev.depthend;
			g.depthend = g.prev.depthend;
			g.depthfrom = 2;
			g.depthendfrom = 2;

			if (g.edgesmask & 1) {
				gate p = g.in0;
				int chain;
				if (g.flags & flag_in0right) chain = p.stackpos1;
				else chain = p.stackpos0;
				if (chain < 0) {
					int depthend = p.depth + edgeweight;
					int depth = depthend + vertexweight;
					if (depth > g.depth)
						g.depth = depth,
						g.depthfrom = 0;
					if (depthend > g.depthend)
						g.depthend = depthend,
						g.depthendfrom = 0;
				}
			}

			if (g.edgesmask & 2) {
				gate p = g.in1;
				int chain;
				if (g.flags & flag_in1right) chain = p.stackpos1;
				else chain = p.stackpos0;
				if (chain < 0) {
					int depthend = p.depth + edgeweight;
					int depth = depthend + vertexweight;
					if (depth > g.depth)
						g.depth = depth,
						g.depthfrom = 1;
					if (depthend > g.depthend)
						g.depthend = depthend,
						g.depthendfrom = 1;
				}
			}
		}

		gate gprev = s.base.prev;
		int lastfrom = 2;
		for (g = gprev; g.depth >= 0; g = gprev) {
			if (lastfrom == 2) lastfrom = g.depthendfrom;
			else if (lastfrom)
				g.stackpos1 = chainno,
				nedges = nedges - 1,
				lastfrom = g.depthfrom;
			else
				g.stackpos0 = chainno,
				nedges = nedges - 1,
				lastfrom = g.depthfrom;

			if (lastfrom == 2)
				gprev = g.prev;
			else if (lastfrom)
				gprev = g.in1,
				lastfrom = !!(g.flags & flag_in1right);
			else
				gprev = g.in0,
				lastfrom = !!(g.flags & flag_in0right);
		}

		if (chainno >= startreg)
			regs.ipush(chainno - startreg);
		else
			mems.ipush(chainno - startmem);

		chainno = chainno + 1;
		if (chainno >= startreg + nregs)
			chainno = startmem;
	}

	for (g = s.base.next; g.depth >= 0; g = g.next) {
		int d0 = g.stackpos0;
		int d1 = g.stackpos1;

		if (d0 >= startreg)
			d0 = startreg + regs[d0 - startreg];
		else if (d0 >= startmem) 
			d0 = startmem + mems[d0 - startmem];

		if (d1 >= startreg)
			d1 = startreg + regs[d1 - startreg];
		else if (d1 >= startmem) 
			d1 = startmem + mems[d1 - startmem];

		int u0 = -1;
		int u1 = -1;

		if (g.edgesmask & 1) {
			if (g.flags & flag_in0right) u0 = g.in0.stackpos1;
			else u0 = g.in0.stackpos0;
		}

		if (g.edgesmask & 2) {
			if (g.flags & flag_in1right) u1 = g.in1.stackpos1;
			else u1 = g.in1.stackpos0;
		}

		int rswap = 0;
		int mswap = 0;
		int d;
		int u;

		if (d0 >= startreg & u0 >= startreg)
			d = d0, u = u0, rswap = 1;
		else if (d0 >= startreg & u1 >= startreg)
			d = d0, u = u1, rswap = 1;
		else if (d1 >= startreg & u0 >= startreg)
			d = d1, u = u0, rswap = 1;
		else if (d0 >= startmem & d0 < startreg & u0 >= startmem & u0 < startreg)
			d = d0, u = u0, mswap = 1;
		else if (d0 >= startmem & d0 < startreg & u1 >= startmem & u1 < startreg)
			d = d0, u = u1, mswap = 1;
		else if (d1 >= startmem & d1 < startreg & u0 >= startmem & u0 < startreg)
			d = d1, u = u0, mswap = 1;

		if (rswap & d != u) {
			if (d0 == d) d0 = u;
			else if (d0 == u) d0 = d;
			if (d1 == d) d1 = u;
			else if (d1 == u) d1 = d;
			d = d - startreg;
			u = u - startreg;
			for (i = 0; i < regs.isize; i = i + 1) {
				if (regs[i] == d) regs[i] = u;
				else if (regs[i] == u) regs[i] = d;
			}
		} else if (mswap & d != u) {
			if (d0 == d) d0 = u;
			else if (d0 == u) d0 = d;
			if (d1 == d) d1 = u;
			else if (d1 == u) d1 = d;
			d = d - startmem;
			u = u - startmem;
			for (i = 0; i < mems.isize; i = i + 1) {
				if (mems[i] == d) mems[i] = u;
				else if (mems[i] == u) mems[i] = d;
			}
		}

		g.stackpos0 = d0;
		g.stackpos1 = d1;
	}

	s.startmem = startmem;
	s.nregs = regs.isize;
	s.nmems = mems.isize;

	return;	
}
