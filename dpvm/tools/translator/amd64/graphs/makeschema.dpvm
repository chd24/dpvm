/* creates schema of code segment; T16.570-T18.013; $DVS:time$ */

#include "graphs.dpvmake"

(const stateful any func, int begin, int end, int beginstack) 
                -> (volatile stateful schema res, int status) {
	schema res;
	gate stack[];
	gate base = res.base;

	if (!begin) beginstack = func.type.l[0].i[9];

	int i;
	for (i = 0; i < beginstack; i = i + 1) {
		gate in;
		in.funcpos = begin - 1;
		in.stackpos0 = i;
		in.stackpos1 = -1;
		in.flags = flag_input;
		in.prev = base.prev;
		base.prev.next = in;
		in.next = base;
		base.prev = in;
		res.inputs.push(in);
		stack.push(in);
	}

	for (i = begin; i <= end; i = i + 1) {
		int c = func.c[i];
		int done;
		
		if (c < 0x80) {
			if (i + 1 <= end) {
				int d = func.c[i + 1];

				if (d == 0xA1) { /* iload */
					if (c >= stack.lsize) {
						destroyschema(res);
						return (res, i << 32 | d << 16 | c << 8 | 1);
					}
					c = stack.lsize - c - 1;

					gate n;
					n.funcpos = i;
					n.stackpos0 = c;
					n.stackpos1 = stack.lsize;
					gate p = stack[c]; 
					n.in0 = p;
					n.edgesmask = 1;
					if (c == p.stackpos0)
						p.out0 = n,
						p.edgesmask = p.edgesmask | 4;
					else
						p.out1 = n, 
						n.flags = n.flags | flag_in0right,
						p.edgesmask = p.edgesmask | 8;

					n.prev = base.prev;
					base.prev.next = n;
					n.next = base;
					base.prev = n;

					stack[c] = n;
					stack.push(n);

					i = i + 1;
					done = 1;

				} else if (d == 0xA5) { /* istore */
					if (c >= stack.lsize - 1) {
						destroyschema(res);
						return (res, i << 32 | d << 16 | c << 8 | 2);
					}
					c = stack.lsize - c - 2;

					gate n;
					n.funcpos = i;
					n.stackpos0 = c;
					n.stackpos1 = -1;
					gate p = stack[stack.lsize - 1]; 
					n.in0 = p;
					n.edgesmask = 1;
					if (stack.lsize - 1 == p.stackpos0)
						p.out0 = n,
						p.edgesmask = p.edgesmask | 4;
					else
						p.out1 = n,
						n.flags = n.flags | flag_in0right,
						p.edgesmask = p.edgesmask | 8;

					n.prev = base.prev;
					base.prev.next = n;
					n.next = base;
					base.prev = n;

					stack[c] = n;
					stack.lpop(1);

					i = i + 1;
					done = 1;

				} else if (d == 0xAD) { /* ipopn */
					if (c > stack.lsize) {
						destroyschema(res);
						return (res, i << 32 | d << 16 | c << 8 | 3);
					}
					stack.lpop(c);

					i = i + 1;
					done = 1;

				} else if (d == 0xC8 | d == 0xC9) { /* shl, shr */
					if (!stack.lsize) {
						destroyschema(res);
						return (res, i << 32 | d << 16 | c << 8 | 4);
					}

					gate n;
					n.op = d - 0xC8 + op_shl;
					n.value = c;

					c = stack.lsize - 1;
					n.funcpos = i;
					n.stackpos0 = c;
					n.stackpos1 = -1;
					gate p = stack[c]; 
					n.in0 = p;
					n.edgesmask = 1;
					if (c == p.stackpos0)
						p.out0 = n,
						p.edgesmask = p.edgesmask | 4;
					else
						p.out1 = n,
						n.flags = n.flags | flag_in0right,
						p.edgesmask = p.edgesmask | 8;

					n.prev = base.prev;
					base.prev.next = n;
					n.next = base;
					base.prev = n;

					stack[c] = n;

					i = i + 1;
					done = 1;					
				}
			}

			if (!done) {
				gate n;
				n.op = op_const;
				n.value = c;
				n.funcpos = i;
				n.stackpos0 = stack.lsize;
				n.stackpos1 = -1;

				n.prev = base.prev;
				base.prev.next = n;
				n.next = base;
				base.prev = n;

				stack.push(n);				
			}

		} else if (c == 0x82) { /* code */
			if (i + 2 > end) {
				destroyschema(res);
				return (res, i << 32 | c << 8 | 5);
			}
			int d = func.c[i + 1];
			if (d >= 0x80) {
				destroyschema(res);
				return (res, i << 32 | d << 16 | c << 8 | 6);
			}
			if (func.c[i + 2] != 0xB1) {
				destroyschema(res);
				return (res, i << 32 | func.c[i + 2] << 16 | c << 8 | 7);
			}
			if (d < 0 | d >= func.isize) {
				destroyschema(res);
				return (res, i << 32 | d << 16 & 0xffff | c << 8 | 8);
			}

			gate n;
			n.op = op_const;
			n.value = func.i[d];
			n.funcpos = i;
			n.stackpos0 = stack.lsize;
			n.stackpos1 = -1;

			n.prev = base.prev;
			base.prev.next = n;
			n.next = base;
			base.prev = n;

			stack.push(n);
			i = i + 2;
			
		} else if (c == 0xA9) { /* ipops */
			if (!stack.lsize) {
				destroyschema(res);
				return (res, i << 32 | c << 8 | 9);
			}
			stack.lpop(1);

		} else if (c == 0x9B | c == 0xCF) { /* neg, not */
			if (!stack.lsize) {
				destroyschema(res);
				return (res, i << 32 | c << 8 | 10);
			}

			gate n;
			if (c == 0x9B) n.op = op_neg;
			else n.op = op_not;

			c = stack.lsize - 1;
			n.funcpos = i;
			n.stackpos0 = c;
			n.stackpos1 = -1;
			gate p = stack[c]; 
			n.in0 = p;
			n.edgesmask = 1;
			if (c == p.stackpos0)
				p.out0 = n,
				p.edgesmask = p.edgesmask | 4;
			else
				p.out1 = n,
				n.flags = n.flags | flag_in0right,
				p.edgesmask = p.edgesmask | 8;

			n.prev = base.prev;
			base.prev.next = n;
			n.next = base;
			base.prev = n;

			stack[c] = n;

                } else if (c >= 0x98 && c <= 0x9A || c >= 0xC0 && c <= 0xC2 || c >= 0xCC && c <= 0xCE) { /* =<>+-*&|^ */
			if (stack.lsize < 2) {
				destroyschema(res);
				return (res, i << 32 | c << 8 | 11);
			}
                        int fullmul;
			if (c == 0xC2) { /* * */
                                if (i + 1 > end || func.c[i + 1] != 0xA9)
                                    fullmul = 1;
                                else
                                    i += 1;
			}

			gate n;
                        if (c == 0x98) n.op = op_eq;
                        else if (c == 0x99) n.op = op_lt;
                        else if (c == 0x9A) n.op = op_gt;
                        else if (c == 0xC0) n.op = op_add;
			else if (c == 0xC1) n.op = op_sub;
                        else if (c == 0xC2) {
                            if (fullmul)
                                n.op = op_fullmul;
                            else
                                n.op = op_mul;
                        } else if (c == 0xCC) n.op = op_and;
			else if (c == 0xCD) n.op = op_or;
			else n.op = op_xor;

			c = stack.lsize - 2;
			int d = stack.lsize - 1;
			n.funcpos = i;
			n.stackpos0 = c;
                        if (fullmul)
                            n.stackpos1 = d;
                        else
                            n.stackpos1 = -1;
			gate p = stack[c]; 
			gate q = stack[d]; 
			n.in0 = p;
			n.in1 = q;
			n.edgesmask = 3;

			if (c == p.stackpos0)
				p.out0 = n,
				p.edgesmask = p.edgesmask | 4;
			else
				p.out1 = n,
				n.flags = n.flags | flag_in0right,
				p.edgesmask = p.edgesmask | 8;

			if (d == q.stackpos0)
				q.out0 = n,
				q.edgesmask = q.edgesmask | 4;
			else
				q.out1 = n,
				n.flags = n.flags | flag_in1right,
				q.edgesmask = q.edgesmask | 8;

			n.prev = base.prev;
			base.prev.next = n;
			n.next = base;
			base.prev = n;

			stack[c] = n;
                        if (fullmul)
                            stack[d] = n;
                        else
                            stack.lpop(1);

                } else if (c == 0x88) { /* ret */
			int r = func.type.l[1].i[9];
			int n = stack.lsize - r;
			if (n) {
				if (n + r > 0x80) {
					destroyschema(res);
					return (res, i << 32 | c << 8 | 14);
				}
				char func1[];
				int j;
				for (j = r - 1; j >= 0; j = j - 1) {
					func1.cpush(j);
					func1.cpush(0xA1); 	/* iload */
					func1.cpush(n + j);
					func1.cpush(0xA5);	/* istore */
				}
				func1.cpush(n);
				func1.cpush(0xAD);		/* ipopn */
				func = func1;
				begin = 0;
				end = func.csize - 1;
				i = -1;
			}
			

		} else {
			destroyschema(res);
			return (res, i << 32 | c << 8 | 15);
		}
	}

	res.startout = 0;

	for (i = res.startout; i < stack.lsize; i = i + 1) {
		gate p = stack[i];
		res.outputs.push(p);
		if (i == p.stackpos0)
			p.flags = p.flags | flag_output0,
			res.outright.ipush(0);
		else
			p.flags = p.flags | flag_output1,
			res.outright.ipush(1);
	}

	return (res, 0);
}
