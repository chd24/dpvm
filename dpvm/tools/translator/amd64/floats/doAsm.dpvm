/* make error for amd64 float computations translator; T19.509-T20.125; $DVS:time$ */

#include "../../../../lib/stdlib/stdlib.dpvmake"
#include "floats.dpvmh"

(const char str[]) -> (int cod) readCode = {
	int i, cod;
	for (i = 0; i < 2 && i < str.csize; i += 1) {
		cod <<= 4;
		int c = str[i];
		if (c >= '0' && c <= '9')
			cod |= c - '0';
		else if (c >= 'A' && c <= 'F')
			cod |= c - 'A' + 10;
		else
			return cod;

	}
	return cod;
};

(volatile stateful floatsData data, char cod) -> () putCode = {
	data.d.machcode.cpush(cod);
	return;
};

(volatile stateful floatsData data, const char str[]) -> () putStr = {
	mach_code mc = data.d.machcode;
	int i;
	for (i = 0; i < str.csize; i += 1)
		mc.cpush(str[i]);
	return;
};

(volatile stateful floatsData data, int n, int nBytes) -> () putHex = {
	const char hex[] = "0123456789ABCDEF";
	mach_code mc = data.d.machcode;
	int i;
	nBytes <<= 3;
	if (n < 0 && mc.csize && mc.c[mc.csize - 1] == '+') {
		n = -n;
		mc.c[mc.csize - 1] = '-';
	}
	for (i = nBytes - 4; i >= 0; i -= 4)
		mc.cpush(hex[n >> i & 0xf]);
	return;
};

(const stateful char str[], const stateful char delims[]) -> (volatile char segments[][]) getDelimsSegments = {
	char segment[], segments[][] = {segment};
	int i, size = str.csize, n = 0, flag;
	for (i = 0; i < size; i += 1) {
		char c = str[i];
		if (strchr(delims, c) >= 0) {
			segments[n].cpush(c);
			flag = 0;
		} else if (!flag) {
			char newSegment[];
			segments.lpush(newSegment);
			n += 1;
			flag = 1;
		}
	}
	return segments;
};

(volatile stateful floatsData data, const char mnemonics[], const char codes[], int reg, int offset) -> () doAsm = {
	if (data.debugLevel) {
		char parts[][] = splitString(codes, " ");
		reg = asmRegs[reg].number;
		int i, Reg = reg >> 3;
		reg &= 7;

		for (i = 0; i < parts.lsize; i += 1) {
			char part[] = parts[i];
			int c = readCode(part);

			if (strstr(part, "+r*") >= 0)
				c += reg * (part[part.csize - 1] - '0');
			else if (strstr(part, "+R*") >= 0)
				c += Reg * (part[part.csize - 1] - '0');
			else if (part.csize == 2 && part[0] == 'b' && part[1] >= '0' && part[1] <= '7')
				c = offset >> ((part[1] - '0') << 3) & 0xff;

			if ((strstr(part, "?r==") < 0 || part[part.csize - 1] == '0' + reg)
					&& (strstr(part, "?R==") < 0 || part[part.csize - 1] == '0' + Reg))
				putCode(data, c);
		}
	} else {
		const char delims[] = " ,[]+()";
		char parts[][] = splitString(mnemonics, delims), segments[][] = getDelimsSegments(mnemonics, delims);
		int i;
		putStr(data, "\t");
		for (i = 0; i < parts.lsize; i += 1) {
			putStr(data, segments[i]);

			char part[] = parts[i];

			if (part == "r")
				putStr(data, asmRegs[reg].name);
			else if (part == "b")
				putHex(data, offset, 1);
			else if (part == "w")
				putHex(data, offset, 2);
			else if (part == "d")
				putHex(data, offset, 4);
			else if (part == "q")
				putHex(data, offset, 8);
			else
				putStr(data, part);
		}
		putStr(data, segments[i]);
		putStr(data, "\r\n");
	}

	return;
};
