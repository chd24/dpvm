/* debugger class, methods implementation, T19.645-T20.133; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.0, T19.354-T19.358 */

int _Z = 0;
#include "../../../common/sysParams.dpvmh"
#include "../../../lib/stdlib/stdlib.dpvmake"
#include "debugger.dpvmake"
#include "version.dpvmh"

(volatile stateful any debuggerObj) -> (const char error[], int flags) getFlags = {
	debuggerImpl impl;
	char err[] = convertObjToImpl(impl, debuggerObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any debuggerObj, int flags) -> (const char error[]) setFlags = {
	debuggerImpl impl;
	char err[] = convertObjToImpl(impl, debuggerObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any debuggerObj, const stateful any registryObj) -> (const char error[]) setRegistry = {
	debuggerImpl impl;
	char err[] = convertObjToImpl(impl, debuggerObj, "setRegistry");
	if (err.csize) return err;

	registryData registry;
	(registry, err) = registryPrepare(registryObj);
	if (err.csize) return err;

	impl.data.registry = registry;
	impl.data.registrySet = 1;
	return "";
};

(const thread t, const any objs, int status) -> () checkHandleAddress = {
	if (status) {
		outputp("", "", "Error: handleAddress is still in use, kill previous debugger.\r\n");
		return;
	}

	const int handlerVars[] = {DPVM_SYS_PARAM_TIME, DPVM_SYS_PARAM_ERROR, DPVM_SYS_PARAM_CODE, DPVM_SYS_PARAM_POS,
			DPVM_SYS_PARAM_FUNC_SHORT, DPVM_SYS_PARAM_ID};
	getsysp(handler, t, handlerVars);

	const int vars[] = {};
	getsysp(collector, t, vars);
	getsys(debugThread, t, vars);
	return;
};

(const thread t, const any objs, int status) -> () checkReportAddress = {
	if (status) {
		outputp("", "", "Error: reportAddress is still in use, kill previous debugger.\r\n");
		return;
	}

	mrecvp("", "", t.handleAddress, 0);
	mrecv(checkHandleAddress, t, t.handleAddress, 0);
	return;
};

(const thread t, const any objs, int status) -> () checkEndAddress = {
	char str[];
	printf(str, "%s\r\n", {t.endAddress.extVersion});
	outputp("", "", str);

	if (status) {
		outputp("", "", "Error: endAddress is still in use, kill previous debugger.\r\n");
		return;
	}

	mrecvp("", "", t.reportAddress, 0);
	mrecv(checkReportAddress, t, t.reportAddress, 0);
	return;
};

(volatile stateful any debuggerObj, const char expression[], const any links, int mode) -> (const char error[]) debug = {
	debuggerImpl impl;
	char err[] = convertObjToImpl(impl, debuggerObj, "debug");
	if (err.csize) return err;

	if (!impl.data.registrySet)
		return mkError("registry is not set", "debug");

	if (!impl.data.bytecodesInited) {
		err = genBytecodes(impl.data);
		if (err.csize) return err;
	}

	if (mode == DEBUG_MODE_GENERATE)
		return "";

	int begin, end, addDebug;
	(begin, end) = strtostr(expression, 0, expression.csize);
	if (end - begin == "debug".csize) {
		char word[];
		substrcat(word, expression, begin, end);
		if (word != "debug")
			addDebug = 1;
	} else
		addDebug = 1;

	if (addDebug) {
		char expr[];
		printf(expr, "debug %s", {expression});
		expression = expr;
	}

	any func;
	(func, err) = impl.data.registry.interpreter(impl.data.registry, expression, links);
	if (err.csize) return err;

	thread t;
	t.function = func;
	t.debugger = impl;

	any funcs[];
	int status;
	(funcs, t.checkerData, err, status) = impl.data.registry.checker(func);
	if (status & 1)
		return err;
	t.mode = mode;

	debuggerAddress addr;
	addr.extVersion = impl.data.extVersion;
	addr.expression = expression;
	addr.serviceNo = DEBUGGER_SERVICE_END;
	t.endAddress = addr;

	debuggerAddress addr1;
	addr1.extVersion = impl.data.extVersion;
	addr1.expression = expression;
	addr1.serviceNo = DEBUGGER_SERVICE_REPORT;
	t.reportAddress = addr1;

	debuggerAddress addr2;
	addr2.extVersion = impl.data.extVersion;
	addr2.expression = expression;
	addr2.serviceNo = DEBUGGER_SERVICE_HANDLE;
	t.handleAddress = addr2;

	mrecvp("", "", addr, 0);
	mrecvp(checkEndAddress, t, addr, 0);
	mrecvp("", "", addr, -1);

	return "";
};

debuggerMethods debuggerMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setRegistry,
	dump,
	debug
};
