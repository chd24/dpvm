/* generate function to process the given bytecode; T16.494-T20.133; $DVS:time$ */

int _Z = 0;
#include "../../../common/bytecodes.dpvmh"
#include "../../../lib/stdlib/stdlib.dpvmake"
#include "debugger.dpvmh"

char codeinout[] = gestate_welcoming_detests; /* codeinout.bin */
char inoutset[] = fibroblast_readily_manuring; /* inoutset.bin */

(int cod) -> (const char text[]) {
	const char types[] = "lifc";
	int ctype;
	int cin;
	int cout;
	int x;
	int i;
	int j;
	int ipos;
	int lpos;
	int nocode;


	/* calculate input/output stack sizes for this code */

	if (cod >= codeinout.csize) cod = DPVM_CODE_ILL;
	ctype = codeinout[cod]; /* codeinout.bin */
	if (ctype >= 0x16) {
		cin = ctype & 0xF;
		cout = ctype >> 4;
	}
	if (ctype < 0x16) {
		cin = ctype;
		cout = 0;
	}

	int tin[];
	x = inoutset[cin << 2] + ((cod >= DPVM_CODE_IO_MIN) << 1); tin.ipush(x);
	x = inoutset[(cin << 2) + 1]; tin.ipush(x);
	x = inoutset[(cin << 2) + 2]; tin.ipush(x);
	x = inoutset[(cin << 2) + 3]; tin.ipush(x);

	int tout[];
	x = inoutset[cout << 2];       tout.ipush(x);
	x = inoutset[(cout << 2) + 1]; tout.ipush(x);
	x = inoutset[(cout << 2) + 2]; tout.ipush(x);
	x = inoutset[(cout << 2) + 3]; tout.ipush(x);


	/* output header */

	char name[];
	print_bytecode(name, cod);
		
	char res[];
	strcat(res, "/* Generated by genBytecode() */\r\n\r\n");
	printf(res, "type thread = %p;\r\n\r\n", {thread});
	printf(res, "(volatile stateful thread t) -> () bytecode_%s = {\r\n", {name});
	strcat(res, "\tasm {\r\n");

	/* extract stack from thread */

	strcat(res, "\t\t0 lload 1 lget\r\n");

	/* get info of stack */

	if (tin[0] || tin[1] || tin[2] || tin[3])
		strcat(res, "\t\t0 lload info lpops\r\n\r\n");


	/* extract input parameters from stack */

	for (i = 3; i >= 0; i -= 1) {
		if (tin[i]) {
			for (j = 0; j < tin[i]; j += 1) {
				lpos = 0;
				if (!i) lpos += j;
				ipos = 3 - i;
				if (i == 1) ipos += j;
				else if (!i) ipos += tin[1];

				strcat(res, "\t\t");
				printint(res, lpos, 1);
				strcat(res, " lload ");
				printint(res, ipos, 1);
				strcat(res, " iload ");
				printint(res, tin[i] - j, 1);
				strcat(res, " sub ");
				res.push(types[i]);
				strcat(res, "get\r\n");
			}

			lpos = 0;
			if (!i) lpos = tin[0];
			strcat(res, "\t\t");
			printint(res, lpos, 1);
			strcat(res, " lload ");
			printint(res, tin[i], 1);
			res.push(' ');
			res.push(types.c[i]);
			strcat(res, "pop\r\n\r\n");
		}
	}


	/* perform bytecode */

	strcat(res, "\t\t");

	if (cod == DPVM_CODE_CODE) {
		printint(res, tin[0] + 1, 1);
		strcat(res, " lload 0 lget");
		nocode = 1;

	} else if (cod >= DPVM_CODE_LB && cod <= DPVM_CODE_JNZF) { /* j*, l* */
		i = cod & 3;
		if (i == 2) {
			strcat(res, "jnzf\r\n\t\t");
		} else if (i == 3) {
			strcat(res, "jzf\r\n\t\t");
		}
		if (i) {
			printint(res, tin[0] + 1, 1);
			strcat(res, " lload 0 lload 0 iget 1 sub 0 lload 2 lget 2 lget iget 0 iset");
		}
		if (i > 1) {
			strcat(res, "\r\n\t\tlf");
		}
		nocode = 1;

	} else if (cod >= DPVM_CODE_LPOPS && cod <= DPVM_CODE_CPOPS) { /* *pops */
		nocode = 1;

	} else if (cod >= DPVM_CODE_LLOAD && cod <= DPVM_CODE_CPOPN) { /* *load, *store, *popn */
		i = cod & 3;
		printint(res, tin[0], 1);
		strcat(res, " lload ");

		if (cod >= DPVM_CODE_LLOAD && cod <= DPVM_CODE_CSTORE) { /* *load, *store */
			strcat(res, "neg ");
			printint(res, tin[1] + 3 - i, 1);
			strcat(res, " iload add ");
			printint(res, tin[i] + 1, 1);
			strcat(res, " sub ");
		}

		cod += DPVM_CODE_LGET - DPVM_CODE_LLOAD;
	}

	if (!nocode) {
		print_bytecode(res, cod);
	}
	strcat(res, "\r\n\r\n");

	
	/* push output parameters to stack */

	for (i = 3; i >= 0; i -= 1) {
		if (tout[i]) {
			for (j = 0; j < tout[i]; j += 1) {
				lpos = tout[0];
				if (!i) lpos += 1;

				strcat(res, "\t\t");
				printint(res, tout[i] - 1 - j, 1);
				res.push(' ');
				res.push(types[i]);
				strcat(res, "load ");
				printint(res, lpos, 1);
				strcat(res, " lload ");
				res.push(types[i]);
				strcat(res, "push\r\n");
			}
			strcat(res, "\r\n");
		}
	}


	/* output footer */

	strcat(res, "\t\tret\r\n\t};\r\n");
	strcat(res, "};\r\n");

	return res;
}
