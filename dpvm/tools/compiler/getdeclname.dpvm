/* dpvm: get declaration name and postfix type modificators; T16.525-T20.114; $DVS:time$ */

/* declname: name [ ( '[' [min[..[.][max]] ']' | (decl,...)) ...]

   context:
	0 - decl in global scope
	1 - decl in function
	2 - type cast in expression
	3 - decl in structure
	4 - decl in funcion parameters
	5 - initializer of type const

   rstatus (in/out):
	bits  0..1:  0 - link, 1 - int, 2 - float, 3 - char
	bit      2:  1 - const
	bit	 3:  1 - stateful
	bit      4:  1 - volatile
	bit      5:  1 - type
	bit      6:  1 - function
	bits 8..62:  hash of name of object is any, 0 otherwise
	bit     63:  1 - error
*/

#include "../../lib/stdlib/stdlib.dpvmake"
#include "compiler.dpvmake"

(volatile stateful compdata data, const (const type, int) getdecl(volatile stateful compdata, int),
                const type res, int context, int rstatus) -> (const type res, int rstatus) {
	int status;
	int pos;
	int end;

	/* read name of object */

	(pos, end, status) = getlexem(data.l[5], lexems, data.i[5], data.i[6]);

	if (status >= maxnames) {
		if (context == CONTEXT_INITIALIZER) {
			data.mess = "identifier is not allowed here";
			return (res, -2);
		} else if (context == CONTEXT_EXPRESSION)
			return (res, -1);
		rstatus |= status;
		data.pos = pos;
		(pos, end, status) = getlexem(data.l[5], lexems, data.i[5], data.i[6]);
	}


	/* process [...] and (decl,...) postfixes */

	while (!status || status == 2) {
		if (!status) {
			if (context <= CONTEXT_EXPRESSION) {
				data.links.ipop(data.links.isize);
				data.ints.ipop(data.ints.isize);
				data.floats.ipop(data.floats.isize);
				data.chars.ipop(data.chars.isize);
				data.ltypes.lpop(data.ltypes.lsize);
			}

			type resout;
			(resout, status) = getdecllist(data, getdecl, context <= CONTEXT_EXPRESSION);
			if (status < 0) {
				if (status == -1)
					data.mess = "(parameters) expected";
				return (res, -2);
			}

			if (!(rstatus & 0x80)) {
				type t;
				t.i[rstatus & 3 | 8] = 1;
				t.i[rstatus & 3 | 12] = 1;
				if (!(rstatus & 3)) t.push(res);
				res = mktype(t, 0);
			}

			type f;
			f.l[0] = resout;
			f.l[1] = res;
			res = mktype(f, 1);
			rstatus &= ~0xe3;
			rstatus |= 0x40;
		} else {
			if (rstatus & 0x80) {
				data.mess = "(parameters) expected";
				return (res, -2);
			}

			if (context <= CONTEXT_EXPRESSION) {
				data.links.ipop(data.links.isize);
				data.ints.ipop(data.ints.isize);
				data.floats.ipop(data.floats.isize);
				data.chars.ipop(data.chars.isize);
				data.ltypes.lpop(data.ltypes.lsize);
			}

			int min = 0;
			int max = (1 << 63) - 1;

			data.pos = pos;

			any lvalue;
			int n;
			float fvalue;
			char cvalue;
			(lvalue, n, status, fvalue, cvalue) = getconstexpr(data, wind_speeded_hogwash, 1);

			if (!status) {
				min = n;

				int i = 0; do {
					(pos, end, status) = getlexem(data.l[5], lexems, data.i[5], data.i[6]);
					if (status == 39) { 
						data.pos = pos;
						i += 1;
					}
				} while (i < 3 && status == 39); /* . */

				if (i == 0)
					max = min;
				else if (i == 1) {
					data.mess = "2 or 3 dots expected";
					return (res, -2);
				} else {
					(lvalue, n, status, fvalue, cvalue) = getconstexpr(data, wind_speeded_hogwash, 1);
					if (!status) max = n;
				}
			}

			(pos, end, status) = getlexem(data.l[5], lexems, data.i[5], data.i[6]);

			if (status != 3) {
				data.mess = "] expected here";
				return (res, -2);
			}
			data.pos = pos;

			type t;
			t.i[rstatus & 3 |  8] = min;
			t.i[rstatus & 3 | 12] = max;
			if (!(rstatus & 3)) {
				t.l[2] = res;
				t.l[3] = res;
			}
			res = mktype(t, 0);
			rstatus &= ~0xe3;
		}

		(pos, end, status) = getlexem(data.l[5], lexems, data.i[5], data.i[6]);
	}

	if (rstatus & 0x80) {
		data.mess = "(parameters) expected";
		return (res, -2);
	}

	if ((rstatus & 3) != 0 && ((rstatus & 0x18) != 0 || (context > CONTEXT_EXPRESSION && (rstatus & 4) != 0))) {
		data.mess = "type modifiers are not allowed for basic type in this context";
		return (res, -2);
	}

	if (res.type == res)
		rstatus |= 0x20;

	return (res, rstatus);
}
