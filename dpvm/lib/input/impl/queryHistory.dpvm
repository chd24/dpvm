/* input class, runServer method implementation, T20.193-T20.331; $DVS:time$ */

int _Z = 0;
#include "../../../common/sysParams.dpvmh"
#include "../../stdlib/stdlib.dpvmake"
#include "../../utils/utils.dpvmake"
#include "../../algorithms/hashtable/hash.dpvmake"
#include "input.dpvmake"

char historyFile[]	= ".dpvm_history.txt";
int HASH_SIZE		= 0x1000;
int READ_SIZE		= 0x100000;
int TIMEOUT		= 1000000000;

type Address = {
	int hash[4];
	int flags;
};

type Message = {
	const Address returnAddr;
	const historyLine lines[];
	const char error[];
	int query;
};

type serverConstData = {
	const char version[];
	const Address addr;		/* address of server */
	const Address returnAddr;	/* address of client part which run the server */
};

type serverData = {
	const serverConstData cdata;
	volatile hashData hash;		/* hash table to find line index by pos in file */
	volatile historyLine old[];	/* lines from existing history file in descending order (indexes -1, -2, ,,,) */
	volatile historyLine new[];	/* new added lines to history in ascending order (indexes 0, 1, ... ) */
	volatile char history[];	/* history file body */
	int fileLength;			/* history file length */
};

type queryData = {
	volatile stateful historyLine lines[];
	volatile stateful inputImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	const Address addr;
	const Address returnAddr;
	int query;
	int stage;
};

(const Address addr, int n) -> () debug = {
	if (addr.flags & INPUT_FLAG_DEBUG) {
		char mess[];
		printf(mess, "[%d]", {n});
		outputp("", "", mess);
	}
	return;
};

(volatile stateful serverData data, const any objs, int status) -> () serverMain = {
	Address addr = data.cdata.addr;
	debug(addr, 100);
	if (status) {
		debug(addr, 101);
		char mess[];
		printf(mess, "error %d while receiving messages on address %p.\r\n", {Message, status});
		outputp("", "", mkError(mess, "queryHistory:serverMain"));
		return;
	}
	int i;
	for (i = 0; i < objs.lsize; i++) {
		debug(addr, 102);
		if (objs.l[i].type == Message) {
			debug(addr, 103);
			Message arr[];
			pushObject(objs.l[i], arr);
			Message m = arr[0], r;
			historyLine lines[];
			char error[] = "";

			if (m.query == HISTORY_QUERY_ADD) {
				debug(addr, 104);
				if (!m.lines.lsize)
					debug(addr, 105), error = mkError("line is not given", "queryHistory:serverMain");
				else {
					debug(addr, 106);
					char line[];
					strcat(line, m.lines[0].text);
					while (line.csize && line[line.csize - 1] <= ' ')
						line.cpop(1);
					if (line.csize) {
						debug(addr, 107);
						historyLine l = {line, data.fileLength};
						int j;
						debug(addr, data.fileLength);
						debug(addr, l.text.csize);
						for (j = 0; j < l.text.csize; j++)
							debug(addr, l.text[j]);
						data.fileLength += l.text.csize + 1;
						data.new.lpush(l);
						hashObj.findAddKeyValue(data.hash, {l.posInFile}, {data.new.lsize - 1});
						debug(addr, l.posInFile);
						debug(addr, data.new.lsize - 1);
						char text[];
						printf(text, "%s\n", {l.text});
						writep({}, {}, historyFile, text, -1);
					}
				}

			} else if (m.query == HISTORY_QUERY_PREV || m.query == HISTORY_QUERY_NEXT || m.query == HISTORY_QUERY_LAST) {
				debug(addr, 108);
				debug(addr, m.query);
				debug(addr, data.old.lsize);
				debug(addr, data.new.lsize);

				int n;
				if (m.query == HISTORY_QUERY_LAST)
					debug(addr, 109), n = data.new.lsize - 1;

				else if (m.lines.lsize) {
					any value;
					int res;
					(value, res) = hashObj.findGetValue(data.hash, {m.lines[0].posInFile});
					debug(addr, 110);
					if (!res)
						debug(addr, 111), error = mkError("line not found in hash table", "queryHistory:serverMain");
					else if (!value.isize)
						debug(addr, 112), error = mkError("incorrect object in hash table", "queryHistory:serverMain");
					else if (value.i[0] >= data.new.lsize || ~value.i[0] >= data.old.lsize)
						debug(addr, 113), error = mkError("line not found in arrays", "queryHistory:serverMain");
					else {
						debug(addr, 114);
						debug(addr, value.i[0]);
						n = value.i[0] + (m.query == HISTORY_QUERY_PREV ? -1 : 1);
					}

				} else
					debug(addr, 115), error = mkError("line is not given", "queryHistory:serverMain");

				if (!error.csize) {
					debug(addr, 116);
					debug(addr, n);
					if (~n == data.old.lsize && data.history.csize) {
						debug(addr, 117);
						if (data.history[data.history.csize - 1] == '\n')
							data.history.cpop(1);
						if (data.history.csize && data.history[data.history.csize - 1] == '\r')
							data.history.cpop(1);
						int pos = strrchr(data.history, '\n') + 1;
						char line[];
						substrcat(line, data.history, pos, data.history.csize);
						data.history.cpop(data.history.csize - pos);
						historyLine l = {line, pos};
						hashObj.findAddKeyValue(data.hash, {l.posInFile}, {~data.old.lsize});
						data.old.lpush(l);
					}

					if (n >= data.new.lsize || ~n >= data.old.lsize)
						debug(addr, 118), error = mkError("end of history", "queryHistory:serverMain");
					else if (n >= 0)
						debug(addr, 119), lines.lpush(data.new[n]);
					else
						debug(addr, 120), lines.lpush(data.old[~n]);
				}

			} else if (m.query == HISTORY_QUERY_GREP) {
				if (m.lines.lsize) {
					debug(addr, 121);
					char text[] = m.lines[0].text;
					int begin = 0, end = data.history.csize;
					while (begin < end) {
						int pos = substrstr(data.history, text, begin, end);
						if (pos >= 0) {
							int left = substrrchr(data.history, begin, pos, '\n');
							if (left >= 0 || !begin) {
								left++;
								int right = substrchr(data.history, pos + text.csize, end, '\n');
								if (right < 0)
									right = end, begin = end;
								else
									begin = right + 1;
								if (right - 1 >= left && data.history[right - 1] == '\r')
									right--;
								char line[];
								substrcat(line, data.history, left, right);
								historyLine l = {line, left};
								lines.lpush(l);
							} else
								begin = pos + text.csize;
						} else
							begin = end;
					}

					int j;
					for (j = data.old.lsize - 1; j >= 0; j--)
						if (strstr(data.old[j].text, text) >= 0)
							lines.lpush(data.old[j]);

					for (j = 0; j < data.new.lsize; j++)
						if (strstr(data.new[j].text, text) >= 0)
							lines.lpush(data.new[j]);

				} else
					debug(addr, 122), error = mkError("line is not given", "queryHistory:serverMain");

			}

			if (lines.lsize)
				debug(addr, 123), r.lines = lines;
			if (error.csize)
				debug(addr, 124), r.error = error;
			msendp("", "", m.returnAddr, r);
			debug(addr, 125);
		} else {
			debug(addr, 126);
			char mess[];
			printf(mess, "type of received message %p equals %p, expected %p.\r\n", {objs.l[i], objs.l[i].type, Message});
			outputp("", "", mkError(mess, "queryHistory:serverMain"));
		}
	}
	debug(addr, 127);
	mrecv(code, data, addr, -1);
	return;
};

(volatile stateful serverData data, const char text[], int status) -> () readHistory = {
	Address addr = data.cdata.addr;
	strcat(data.history, text);
	debug(addr, 92);
	debug(addr, status);
	if (status != READ_SIZE) {
		debug(addr, 93);
		data.fileLength = data.history.csize;
		serverMain(data, {}, 0);
		return;
	}
	read(code, data, historyFile, data.history.csize, READ_SIZE);
	return;
};

(const stateful char name[]) -> () setTaskName = {
	int vars[], values[], i, size = name.csize, value, shift, var = DPVM_SYS_PARAM_NAME, stop;

	while (size && !stop) {
		int c = name[size - 1];
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
			size -= 1;
		else
			stop = 1;
	}

	stop = 0;
	while (i < size && !stop) {
		int c = name[i];
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
			i += 1;
		else
			stop = 1;
	}

	for (0; i < size; i += 1) {
		value |= name[i] << shift;
		shift += 8;
		if (shift == 64 || i == size - 1) {
			vars.ipush(var);
			values.ipush(value);
			var += 1;
			value = 0;
			shift = 0;
		}
	}

	setsysp("", "", vars, values);
	return;
};

(volatile stateful serverData data, const any objs, int status) -> () serverInit = {
	Address addr = data.cdata.addr;
	debug(addr, 91);
	msendp("", "", data.cdata.returnAddr, (Message){});
	if (status) {
		debug(addr, 92);
		return;
	}
	char name[];
	printf(name, "history server for %s (", {data.cdata.version});
	printobjname(name, addr.hash[0] << 17 >> 17);
	printf(name, ", flags %x)", {addr.flags});
	setTaskName(name);
	hashObj.initExt(data.hash, HASH_SIZE, hashFlagKeyValue);
	readHistory(data, "", READ_SIZE);
	return;
};

(const serverConstData cdata, const int values[]) -> () serverStart = {
	debug(cdata.addr, 90);
	debug(cdata.addr, values[0]);
	serverData data = {cdata};
	mrecv(serverInit, data, cdata.addr, 0);
	return;
};

(volatile stateful queryData data, const any objs, int status) -> () queryMain = {
	if (!data.stage) {
		debug(data.addr, 4);
		if (status || !objs.lsize) {
			debug(data.addr, 5);
			mrecvp("", "", data.returnAddr, 1 << 63);
			return data.callback(data.data, mkError("timeout expired, no response from history server", "queryHistory:queryMain"));
		}

		data.impl.data.serverRunned = 1;
		data.stage = 1;

		historyLine lines[];
		int i;
		for (i = 0; i < data.lines.lsize; i++)
			lines.lpush(data.lines[i]);
		data.lines.lpop(data.lines.lsize);
		Message m = {data.returnAddr, lines, "", data.query};
		msendp("", "", data.addr, m);
		debug(data.addr, 6);
		mrecv(code, data, data.returnAddr, TIMEOUT);
	} else {
		debug(data.addr, 7);
		mrecvp("", "", data.returnAddr, 1 << 63);
		debug(data.addr, 8);
		if (status || !objs.lsize)
			return data.callback(data.data, mkError("timeout expired, no response from history server", "queryHistory:queryMain"));
		debug(data.addr, 9);
		if (objs.l[0].type != Message)
			return data.callback(data.data, mkError("illegal type of message", "queryHistory:queryMain"));
		debug(data.addr, 10);
		Message arr[];
		pushObject(objs.l[0], arr);
		Message m = arr[0];
		if (m.error.csize)
			return data.callback(data.data, m.error);
		debug(data.addr, 11);
		debug(data.addr, m.lines.lsize);
		int i;
		for (i = 0; i < m.lines.lsize; i++)
			debug(data.addr, m.lines[i].posInFile), data.lines.lpush(m.lines[i]);
		debug(data.addr, 12);
		data.callback(data.data, "");
	}
	return;
};

(volatile stateful queryData data, const int values[]) -> () queryStart = {
	int h[4];
	(h[0], h[1], h[2], h[3]) = getfullhash({data.addr, values[0], values[1]});
	data.returnAddr = (Address){h, data.addr.flags};
	mrecvp("", "", data.returnAddr, 0);

	if (data.impl.data.serverRunned) {
		debug(data.addr, 2);
		queryMain(data, (Message []){(Message){}}, 0);
	} else {
		debug(data.addr, 3);
		setsysp(serverStart, (serverConstData){data.impl.methods.version, data.addr, data.returnAddr},
				(const int[]){DPVM_SYS_PARAM_ID}, (const int[]){0});
		mrecv(queryMain, data, data.returnAddr, TIMEOUT);
	}
	return;
};

(volatile stateful historyLine lines[], volatile stateful any inputObj,
		const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data, int query) -> () queryHistory = {
	inputImpl impl;
	char err[] = convertObjToImpl(impl, inputObj, "queryHistory");
	if (err.csize) return callback(data, err);

	int h[4];
	(h[0], h[1], h[2], h[3]) = getfullhash(impl.data.createFunc);
	Address addr = {h, impl.data.flags};
	queryData d = {lines, impl, callback, data, addr, addr, query};

	debug(addr, 777);
	debug(addr, impl.data.flags);
	debug(addr, h[0]);
	debug(addr, h[1]);
	debug(addr, h[2]);
	debug(addr, h[3]);

	getsys(queryStart, d, (int[]){DPVM_SYS_PARAM_TIME, DPVM_SYS_PARAM_ID});
	return callback(data, "");
};
