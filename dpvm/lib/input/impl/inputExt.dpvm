/* input class, inputExt method implementation, T20.221-T20.297; $DVS:time$ */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "input.dpvmake"

/* telnet command codes */
int T_ECHO	=   1;
int T_SUPP_GA	=   3;
int T_LINEMODE	=  34;
int T_SUPP_ECHO	=  45;
int T_SE	= 240;
int T_SB	= 250;
int T_WILL	= 251;
int T_WONT	= 252;
int T_DO	= 253;
int T_DONT	= 254;
int T_IAC	= 255;

/* states */
int S_NORM	= 0;
int S_IAC	= 1;	/* IAC received */
int S_WD	= 2;	/* WILL/WONT/DO/DONT after IAC */
int S_SB	= 3;	/* SB received */
int S_SE	= 4;	/* SE awaited */
int S_ESC	= 5;	/* ^[ */
int S_ESC_BR	= 6;	/* ^[[ */

type inputExtData = {
	volatile stateful char line[];
	volatile stateful char symbol[];
	volatile stateful inputImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	int maxSize;
	int timeout;
	int state;
	int lineOffset;
	int outOffset;
};

(volatile stateful inputExtData data, const char text[], int status) -> () inputCallback = {
	char out[];
	int i;
	for (i = 0; i < text.csize; i++) {
		int c = text[i];

		if (data.state == S_NORM) {
			if (c == T_IAC)
				data.symbol.cpop(data.symbol.csize),
				data.state = S_IAC;

			else if (c == 0x1b)
				data.symbol.cpop(data.symbol.csize),
				data.state = S_ESC;

			else if (c == '\r' || c == '\n') {
				out.cpush('\r');
				out.cpush('\n');
				out.cpush(T_IAC), out.cpush(T_DO), out.cpush(T_LINEMODE);
				out.cpush(T_IAC), out.cpush(T_SB), out.cpush(T_LINEMODE), out.cpush(1), out.cpush(1),
					out.cpush(T_IAC), out.cpush(T_SE);
				out.cpush(T_IAC), out.cpush(T_WONT), out.cpush(T_ECHO);
				if (out.csize)
					outputp("", "", out);
				data.callback(data.data, "");
				return;

			} else if (c == 0x7f) { /* backspace */
				data.symbol.cpop(data.symbol.csize);
				if (data.lineOffset && data.outOffset) {
					int oldLineOffset = data.lineOffset;
					do
						data.lineOffset--;
					while (data.lineOffset && data.line[data.lineOffset] >> 6 == 2);
					data.outOffset--;
					int from, to, todo;
					out.cpush('\b');
					for (from = oldLineOffset, to = data.lineOffset; from < data.line.csize; from++, to++) {
						data.line[to] = data.line[from];
						out.cpush(data.line[to]);
						if (data.line[to] >> 6 != 2)
							todo++;
					}
					data.line.cpop(from - to);
					out.cpush(' ');
					do {
						out.cpush('\b');
						todo--;
					} while (todo >= 0);
				}

			} else if (data.line.csize + (c < 0x80 || c >= 0xc0 ? 0 : data.symbol.csize) < data.maxSize) {
				if (c < 0x80 || c >= 0xc0)
					data.symbol.cpop(data.symbol.csize);
				data.symbol.cpush(c);
				int uni, next;
				(uni, next) = scanutf8(data.symbol, 0, data.symbol.csize);
				if (uni >= 0 && next == data.symbol.csize) {
					int j, size0 = data.line.csize, count;
					for (j = 0; j < next; j++) {
						data.line.cpush(0);
						out.cpush(data.symbol[j]);
					}
					for (j = data.lineOffset; j < size0; j++) {
						c = data.line[j];
						out.cpush(c);
						count += c < 0x80 || c >= 0xc0;
					}
					for (j = size0 - 1; j >= data.lineOffset; j--)
						data.line[j + next] = data.line[j];
					for (j = 0; j < next; j++) {
						data.line[data.lineOffset] = data.symbol[j];
						data.lineOffset++;
					}
					for (j = 0; j < count; j++)
						out.cpush('\b');
					data.outOffset++;
					data.symbol.cpop(next);
				}
			}

		} else if (data.state == S_ESC) {
			if (c == '[')
				data.state = S_ESC_BR;
			else
				data.state = S_NORM;

		} else if (data.state == S_ESC_BR) {
				data.state = S_NORM;

				if (c == 'A') { /* Up */

				} else if (c == 'B') { /* Down */

				} else if (c == 'C' && data.lineOffset < data.line.csize) { /* Right */
					c = data.line[data.lineOffset];
					do {
						out.cpush(c);
						data.lineOffset++;
						if (data.lineOffset < data.line.csize)
							c = data.line[data.lineOffset];
					} while (data.lineOffset < data.line.csize && c >= 0x80 && c < 0xc0);
					data.outOffset++;

				} else if (c == 'D' && data.lineOffset && data.outOffset) { /* Left */
					do {
						data.lineOffset--;
						c = data.line[data.lineOffset];
					} while (data.lineOffset && c >= 0x80 && c < 0xc0);
					data.outOffset--;
					out.cpush('\b');

				}

		} else if (data.state == S_IAC) {
			if (c == T_WILL || c == T_WONT || c == T_DO || c == T_DONT)
				data.state = S_WD;
			else if (c == T_SB)
				data.state = S_SB;
			else
				data.state = S_NORM;

		} else if (data.state == S_WD) {
			data.state = S_NORM;

		} else if (data.state == S_SB) {
			if (c == T_IAC)
				data.state = S_SE;

		} else if (data.state == S_SE) {
			if (c == T_SE)
				data.state = S_NORM;
			else
				data.state = S_SB;
		}
	}

	if (out.csize)
		outputp("", "", out);
	input(code, data, data.maxSize, data.timeout);
	return;
};

(volatile stateful char line[], volatile stateful any inputObj,
		const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data, int maxSize, int timeout) -> () inputExt = {
	inputImpl impl;
	char err[] = convertObjToImpl(impl, inputObj, "inputExt");
	if (err.csize) return callback(data, err);

	inputExtData d = {line, (volatile char[]){}, impl, callback, data, maxSize, timeout};

	char cntl[];
	cntl.cpush(T_IAC), cntl.cpush(T_DO), cntl.cpush(T_LINEMODE);
	cntl.cpush(T_IAC), cntl.cpush(T_SB), cntl.cpush(T_LINEMODE), cntl.cpush(1), cntl.cpush(0), cntl.cpush(T_IAC), cntl.cpush(T_SE);
	cntl.cpush(T_IAC), cntl.cpush(T_WILL), cntl.cpush(T_ECHO);
	outputp("", "", cntl);

	input(inputCallback, d, maxSize, timeout);
	return callback(data, "");
};
