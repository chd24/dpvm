/* input class, inputExt method implementation, T20.221-T20.328; $DVS:time$ */

int _Z = 0;
#include "../../../common/sysParams.dpvmh"
#include "../../../common/taskFlags.dpvmh"
#include "../../stdlib/stdlib.dpvmake"
#include "../../utils/utils.dpvmake"
#include "input.dpvmake"

/* telnet command codes */
int T_ECHO	=   1;
int T_SUPP_GA	=   3;
int T_LINEMODE	=  34;
int T_SUPP_ECHO	=  45;
int T_SE	= 240;
int T_SB	= 250;
int T_WILL	= 251;
int T_WONT	= 252;
int T_DO	= 253;
int T_DONT	= 254;
int T_IAC	= 255;

/* states */
int S_NORM	= 0;
int S_IAC	= 1;	/* IAC received */
int S_WD	= 2;	/* WILL/WONT/DO/DONT after IAC */
int S_SB	= 3;	/* SB received */
int S_SE	= 4;	/* SE awaited */
int S_ESC	= 5;	/* ^[ */
int S_ESC_BR	= 6;	/* ^[[ */

type inputExtData = {
	volatile stateful char line[];
	volatile stateful char line0[];
	volatile stateful char text[];
	volatile stateful char symbol[];
	volatile stateful inputImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	const (volatile stateful any data, const char error[]) -> () historyCallback;
	volatile stateful any data;
	volatile stateful historyLine lines[];
	const stateful historyLine lastLine;
	int maxSize;
	int timeout;
	int state;
	int lineOffset;
	int outOffset;
	int historyQuery;
	int lastLineSet;
	int taskFlags;
};

(volatile stateful inputExtData data, const char text[], int status) -> () inputCallback = {
	char out[];

	if (data.text.csize) {
		strcat(data.text, text);
		text = data.text;
		data.text = (volatile char[]){};
	}

	int i;
	for (i = 0; i < text.csize; i++) {
		int c = text[i];

		if (data.state == S_NORM) {
			if (c == T_IAC)
				data.symbol.cpop(data.symbol.csize),
				data.state = S_IAC;

			else if (c == 0x1b)
				data.symbol.cpop(data.symbol.csize),
				data.state = S_ESC;

			else if (c == '\r' || c == '\n') {
				if (data.taskFlags & DPVM_TASK_FLAG_NO_INPUT_ECHO)
					out.cpop(out.csize);
				out.cpush('\r');
				out.cpush('\n');
				out.cpush(T_IAC), out.cpush(T_DO), out.cpush(T_LINEMODE);
				out.cpush(T_IAC), out.cpush(T_SB), out.cpush(T_LINEMODE), out.cpush(1), out.cpush(1),
					out.cpush(T_IAC), out.cpush(T_SE);
				out.cpush(T_IAC), out.cpush(T_WONT), out.cpush(T_ECHO);
				if (out.csize)
					outputp("", "", out);
				char txt[];
				strcat(txt, data.line);
				historyLine line = {txt, 0}, lines[] = {line};
				strcat(data.line, "\r\n");
				if (data.taskFlags & DPVM_TASK_FLAG_NO_INPUT_HISTORY)
					data.callback(data.data, "");
				else
					data.impl.methods.queryHistory(lines, data.impl, data.callback, data.data, HISTORY_QUERY_ADD);
				return;

			} else if (c == 0x7f) { /* backspace */
				data.symbol.cpop(data.symbol.csize);
				if (data.lineOffset && data.outOffset) {
					int oldLineOffset = data.lineOffset;
					do
						data.lineOffset--;
					while (data.lineOffset && data.line[data.lineOffset] >> 6 == 2);
					data.outOffset--;
					int from, to, todo;
					out.cpush('\b');
					for (from = oldLineOffset, to = data.lineOffset; from < data.line.csize; from++, to++) {
						data.line[to] = data.line[from];
						out.cpush(data.line[to]);
						if (data.line[to] >> 6 != 2)
							todo++;
					}
					data.line.cpop(from - to);
					out.cpush(' ');
					do {
						out.cpush('\b');
						todo--;
					} while (todo >= 0);
				}

			} else if (data.line.csize + (c < 0x80 || c >= 0xc0 ? 0 : data.symbol.csize) < data.maxSize) {
				if (c < 0x80 || c >= 0xc0)
					data.symbol.cpop(data.symbol.csize);
				data.symbol.cpush(c);
				int uni, next;
				(uni, next) = scanutf8(data.symbol, 0, data.symbol.csize);
				if (uni >= 0 && next == data.symbol.csize) {
					int j, size0 = data.line.csize, count;
					for (j = 0; j < next; j++) {
						data.line.cpush(0);
						out.cpush(data.symbol[j]);
					}
					for (j = data.lineOffset; j < size0; j++) {
						c = data.line[j];
						out.cpush(c);
						count += c < 0x80 || c >= 0xc0;
					}
					for (j = size0 - 1; j >= data.lineOffset; j--)
						data.line[j + next] = data.line[j];
					for (j = 0; j < next; j++) {
						data.line[data.lineOffset] = data.symbol[j];
						data.lineOffset++;
					}
					for (j = 0; j < count; j++)
						out.cpush('\b');
					data.outOffset++;
					data.symbol.cpop(next);
				}
			}

		} else if (data.state == S_ESC) {
			if (c == '[')
				data.state = S_ESC_BR;
			else
				data.state = S_NORM;

		} else if (data.state == S_ESC_BR) {
				data.state = S_NORM;

				if (c == 'A' && (!data.historyQuery || data.lines.lsize)
						|| (c == 'B' && data.lines.lsize)) { /* Up, Down */
					substrcat(data.text, text, i + 1, text.csize);
					data.historyQuery = c == 'B' ? HISTORY_QUERY_NEXT : data.historyQuery
							? HISTORY_QUERY_PREV : HISTORY_QUERY_LAST;
					if (data.lines.lsize) {
						data.lastLine = data.lines[0];
						data.lastLineSet = 1;
					}
					data.impl.methods.queryHistory(data.lines, data.impl, data.historyCallback,
							data, data.historyQuery);
					return;

				} else if (c == 'C' && data.lineOffset < data.line.csize) { /* Right */
					c = data.line[data.lineOffset];
					do {
						out.cpush(c);
						data.lineOffset++;
						if (data.lineOffset < data.line.csize)
							c = data.line[data.lineOffset];
					} while (data.lineOffset < data.line.csize && c >= 0x80 && c < 0xc0);
					data.outOffset++;

				} else if (c == 'D' && data.lineOffset && data.outOffset) { /* Left */
					do {
						data.lineOffset--;
						c = data.line[data.lineOffset];
					} while (data.lineOffset && c >= 0x80 && c < 0xc0);
					data.outOffset--;
					out.cpush('\b');

				}

		} else if (data.state == S_IAC) {
			if (c == T_WILL || c == T_WONT || c == T_DO || c == T_DONT)
				data.state = S_WD;
			else if (c == T_SB)
				data.state = S_SB;
			else
				data.state = S_NORM;

		} else if (data.state == S_WD) {
			data.state = S_NORM;

		} else if (data.state == S_SB) {
			if (c == T_IAC)
				data.state = S_SE;

		} else if (data.state == S_SE) {
			if (c == T_SE)
				data.state = S_NORM;
			else
				data.state = S_SB;
		}
	}

	if (out.csize && !(data.taskFlags & DPVM_TASK_FLAG_NO_INPUT_ECHO))
		outputp("", "", out);
	input(code, data, data.maxSize, data.timeout);
	return;
};

(const stateful char str[]) -> (int size) outputSize = {
	int i, size;
	for (i = 0; i < str.csize; i++) {
		int c = str[i];
		size += c < 0x80 || c >= 0xc0;
	}
	return size;
};

(volatile stateful any d, const char error[]) -> () historyCallback = {
	inputExtData arr[];
	pushObject(d, arr);
	inputExtData data = arr[0];

	if (error.csize && strstr(error, "history is empty") < 0 && strstr(error, "end of history") < 0)
		return data.callback(data.data, error);

	if (data.lines.lsize || data.historyQuery == HISTORY_QUERY_NEXT) {
		int oldsize = outputSize(data.line);
		if (data.lines.lsize) {
			if (data.historyQuery == HISTORY_QUERY_LAST) {
				data.line0.cpop(data.line0.csize);
				strcat(data.line0, data.line);
			}
			data.line.cpop(data.line.csize);
			strcat(data.line, data.lines[0].text);
		} else {
			data.line.cpop(data.line.csize);
			strcat(data.line, data.line0);
			data.line0.cpop(data.line0.csize);
			data.historyQuery = 0;
		}
		int newsize = outputSize(data.line), i;
		char out[];
		for (i = 0; i < data.outOffset; i++)
			out.cpush('\b');
		strcat(out, data.line);
		for (i = 0; i < oldsize - newsize; i++)
			out.cpush(' ');
		for (i = 0; i < oldsize - newsize; i++)
			out.cpush('\b');
		if (out.csize)
			outputp("", "", out);
		data.outOffset = newsize;
		data.lineOffset = data.line.csize;
	} else if (data.historyQuery == HISTORY_QUERY_PREV && data.lastLineSet)
		data.lines.lpush(data.lastLine);

	return inputCallback(data, "", 0);
};

(volatile stateful inputExtData data, const int values[]) -> () taskFlagsCallback = {
	data.taskFlags = values[0];
	input(inputCallback, data, data.maxSize, data.timeout);
	return;
};

(volatile stateful char line[], volatile stateful any inputObj,
		const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data, int maxSize, int timeout) -> () inputExt = {
	inputImpl impl;
	char err[] = convertObjToImpl(impl, inputObj, "inputExt");
	if (err.csize) return callback(data, err);

	inputExtData d = {line, (volatile char[]){}, (volatile char[]){}, (volatile char[]){}, impl, callback, historyCallback,
			data, (volatile historyLine[]){}, (const historyLine){}, maxSize, timeout};

	char cntl[];
	cntl.cpush(T_IAC), cntl.cpush(T_DO), cntl.cpush(T_LINEMODE);
	cntl.cpush(T_IAC), cntl.cpush(T_SB), cntl.cpush(T_LINEMODE), cntl.cpush(1), cntl.cpush(0), cntl.cpush(T_IAC), cntl.cpush(T_SE);
	cntl.cpush(T_IAC), cntl.cpush(T_WILL), cntl.cpush(T_ECHO);
	outputp("", "", cntl);

	getsys(taskFlagsCallback, d, (const int[]){DPVM_SYS_PARAM_FLAGS});
	return;
};
