/* input class, inputExt method implementation, T20.221-T20.243; $DVS:time$ */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "input.dpvmake"

/* telnet command codes */
int T_ECHO	=   1;
int T_SUPP_GA	=   3;
int T_LINEMODE	=  34;
int T_SUPP_ECHO	=  45;
int T_SE	= 240;
int T_SB	= 250;
int T_WILL	= 251;
int T_WONT	= 252;
int T_DO	= 253;
int T_DONT	= 254;
int T_IAC	= 255;

/* states */
int S_NORM	= 0;
int S_IAC	= 1;	/* IAC received */
int S_WD	= 2;	/* WILL/WONT/DO/DONT after IAC */
int S_SB	= 3;	/* SB received */
int S_SE	= 4;	/* SE awaited */

type inputExtData = {
	volatile stateful char line[];
	volatile stateful inputImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	int maxSize;
	int timeout;
	int state;
	int lineOffset;
	int outOffset;
};

(volatile stateful inputExtData data, const char text[], int status) -> () inputCallback = {
	char out[];
	int i;
	for (i = 0; i < text.csize; i++) {
		int c = text[i];

		if (data.state == S_NORM) {
			if (c == T_IAC)
				data.state = S_IAC;

			else if (c == '\r' || c == '\n') {
				out.cpush('\r');
				out.cpush('\n');
				out.cpush(T_IAC), out.cpush(T_DO), out.cpush(T_LINEMODE);
				out.cpush(T_IAC), out.cpush(T_SB), out.cpush(T_LINEMODE), out.cpush(1), out.cpush(1),
					out.cpush(T_IAC), out.cpush(T_SE);
				out.cpush(T_IAC), out.cpush(T_WONT), out.cpush(T_ECHO);
				if (out.csize)
					outputp("", "", out);
				data.callback(data.data, "");
				return;

			} else if (c == 0x7f) { /* backspace */
				if (data.lineOffset && data.outOffset) {
					int oldLineOffset = data.lineOffset;
					do
						data.lineOffset--;
					while (data.lineOffset && data.line[data.lineOffset] >> 6 == 2);
					data.outOffset--;
					int from, to, todo;
					out.cpush('\b');
					for (from = oldLineOffset, to = data.lineOffset; from < data.line.csize; from++, to++) {
						data.line[to] = data.line[from];
						out.cpush(data.line[to]);
						if (data.line[to] >> 6 != 2)
							todo++;
					}
					data.line.cpop(from - to);
					out.cpush(' ');
					do {
						out.cpush('\b');
						todo--;
					} while (todo >= 0);
				}

			} else if (data.line.csize < data.maxSize) {
				data.line.cpush(c);
				out.cpush(c);
				data.lineOffset++;
				if (c < 0x80 || c >= 0xc0)
					data.outOffset++;
			}

		} else if (data.state == S_IAC) {
			if (c == T_WILL || c == T_WONT || c == T_DO || c == T_DONT)
				data.state = S_WD;
			else if (c == T_SB)
				data.state = S_SB;
			else
				data.state = S_NORM;

		} else if (data.state == S_WD) {
			data.state = S_NORM;

		} else if (data.state == S_SB) {
			if (c == T_IAC)
				data.state = S_SE;

		} else if (data.state == S_SE) {
			if (c == T_SE)
				data.state = S_NORM;
			else
				data.state = S_SB;
		}
	}

	if (out.csize)
		outputp("", "", out);
	input(code, data, data.maxSize, data.timeout);
	return;
};

(volatile stateful char line[], volatile stateful any inputObj,
		const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data, int maxSize, int timeout) -> () inputExt = {
	inputImpl impl;
	char err[] = convertObjToImpl(impl, inputObj, "inputExt");
	if (err.csize) return callback(data, err);

	inputExtData d = {line, impl, callback, data, maxSize, timeout};

	char cntl[];
	cntl.cpush(T_IAC), cntl.cpush(T_DO), cntl.cpush(T_LINEMODE);
	cntl.cpush(T_IAC), cntl.cpush(T_SB), cntl.cpush(T_LINEMODE), cntl.cpush(1), cntl.cpush(0), cntl.cpush(T_IAC), cntl.cpush(T_SE);
	cntl.cpush(T_IAC), cntl.cpush(T_WILL), cntl.cpush(T_ECHO);
	outputp("", "", cntl);

	input(inputCallback, d, maxSize, timeout);
	return callback(data, "");
};
