/* dfs class, resizeFile method implementation, T18.990-T19.351; $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "../../../utils/utils.dpvmake"
#include "dfs.dpvmake"

type treeSector = {
	int nPart;
	int offset;
	int nLinks;
};

type resizeFileData = {
	const (volatile stateful any data, const stateful int volume[], int begin, int changeBegin, int changeEnd) -> () writeCallback;
	volatile stateful any data;
	volatile stateful dfsImpl impl;
	volatile stateful treeSector sectors[];
};

(volatile stateful resizeFileData d, int sector, int level) -> (const char error[], int size) getMaxSize = {
	if (!level)
		return ("", 0);
	if (level > 9)
		return (mkError("file tree height not supported", "getMaxSize"), 0);

	dfsPart parts[] = d.impl.data.parts;
	int res;

	for (level -= 1; level; level -= 1) {
		int volume[], inode = sector << 6, inodeBegin, inodeEnd, i, n;

		for (n = 0; n < parts.lsize && (inode < inodeBegin || inode + 0x40 > inodeEnd); n += 1)
			volume = parts[i].volume, inodeBegin = parts[i].begin, inodeEnd = inodeBegin + volume.isize;

		if (inode < inodeBegin || inode + 0x40 > inodeEnd)
			return (mkError("need more volume data", "getMaxSize"), inode);

		int pos = inode - inodeBegin;

		for (i = 0; i < 0x40 && volume[pos + i]; i += 1);

		if (!i)
			return (mkError("illegal file tree", "getMaxSize"), res);

		treeSector ts = {n - 1, pos, i};
		d.sectors.lpush(ts);

		i -= 1;
		res += i << level * 6;
		sector = volume[pos + i];
	}

	return ("", res + ((sector != 0) << 6));
};

(volatile stateful resizeFileData d, int nPart, int changeBegin, int changeEnd) -> () applyChanges = {
	dfsPart parts[] = d.impl.data.parts;
	int volume[] = parts[nPart].volume, vbegin = parts[nPart].begin;

	if (d.impl.data.flags & DFS_FLAG_DEBUG) {
		char mess[];
		printf(mess, "[applyChanges: nPart=%X, changeBegin=%X, changeEnd=%X]\r\n", {nPart, changeBegin, changeEnd});
		outputp("", "", mess);
	}

	d.writeCallback(d.data, volume, vbegin, changeBegin, changeEnd);

	int i, j, begin = changeBegin + vbegin, end = changeEnd + vbegin;

	for (i = nPart + 1; i < parts.lsize; i += 1)
		if (begin >= parts[i].begin && end <= parts[i].begin + parts[i].volume.isize)
			for (j = begin; j < end; j += 1)
				parts[i].volume[j - parts[i].begin] = volume[j - vbegin];

	return;
};

(volatile stateful resizeFileData d, int oldSector, int oldSize, int newSize) -> (const char error[], int newSector, int newLevel) resizeFileTree = {
	int oldLevelSizes[], newLevelSizes[], oldNLevels, newNLevels, oldNLinkSectors, newNLinkSectors, i, sectorsInode;
	dfsPart parts[] = d.impl.data.parts;

	if (!parts.lsize || parts[0].begin || parts[0].volume.isize < 0x80)
		return (mkError("volume part is not set or illegal", "resizeFileTree"), 0, 0);

	for (i = 0x40; i < 0x80; i += 4)
		if ((parts[0].volume[i] & 0xff) == DFS_INODE_SECTORS)
			sectorsInode = i, i = 0x80;

	if (!sectorsInode)
		return (mkError("can't find sectors inode in sector 1", "resizeFileTree"), 0, 0);

	(oldLevelSizes, oldNLevels, oldNLinkSectors) = getFileTreeParams(oldSize);
	(newLevelSizes, newNLevels, newNLinkSectors) = getFileTreeParams(newSize);

	int linkSector = parts[0].volume[sectorsInode | 3] + 1, linkSector0 = linkSector, nSector = linkSector + newNLinkSectors - oldNLinkSectors, newSector;

	if (newLevelSizes.isize == 1) {
		newSector = nSector, nSector += 1;

	} else if (newLevelSizes.isize) {
		if (oldNLevels == newNLevels)
			newSector = oldSector;
		else
			newSector = linkSector, linkSector += 1;

		int n, j, links[];

		for (j = newLevelSizes.isize - 2; j >= 0; j -= 1) {
			int size = newLevelSizes[j], lim = newLevelSizes[j + 1] << 6, k;

			if (j == oldLevelSizes.isize - 1) {
				links.ipush(oldSector);
				k = 1;
			} else if (j < oldLevelSizes.isize - 1) {
				if (n >= d.sectors.lsize) {
					char mess[];
					printf(mess, "internal error, mismatched array sizes (oldLevelSizes.isize=%X, d.sectors.lsize=%X, j=%X, n=%X, size=%X, lim=%X, links.isize=%X)",
					       {oldLevelSizes.isize, d.sectors.lsize, j, n, size, lim, links.isize});
					return (mkError(mess, "resizeFileTree"), 0, 0);
				}

				int oldLevelSize = oldLevelSizes[j], offset = d.sectors[n].offset, length;

				if ((oldLevelSize & 0x3f) != (d.sectors[n].nLinks & 0x3f))
					return (mkError("internal error, mismatched number of links", "resizeFileTree"), 0, 0);

				dfsPart part = parts[d.sectors[n].nPart];

				for (k = oldLevelSize; k < size && k & 0x3f; k += 1, length += 1) {
					if (j)
						part.volume[offset + (k & 0x3f)] = linkSector, linkSector += 1;
					else
						part.volume[offset + (k & 0x3f)] = nSector, nSector += 1;
				}

				if (oldLevelSize & 0x3f)
					applyChanges(d, d.sectors[n].nPart, offset + (oldLevelSize & 0x3f), offset + (oldLevelSize & 0x3f) + length);

				n += 1;
			}

			int newlinks = k < size;

			for (k = k; k < size; k += 1) {
				if (j)
					links.ipush(linkSector), linkSector += 1;
				else
					links.ipush(nSector), nSector += 1;
			}

			if (newlinks)
				for(k = k; k < lim; k += 1)
					links.ipush(0);
		}

		if (links.isize) {
			char error[] = d.impl.methods.addVolumePart(d.impl, links, linkSector0 << 6);
			if (error.csize)
				return (error, 0, 0);

			applyChanges(d, parts.lsize - 1, 0, links.isize);
		}
	}

	int arraySaved[];

	while (linkSector < nSector) {
		int todo = (nSector - linkSector) << 6, array[];
		if (todo >= 0x20000) {
			todo = 0x20000;
			if (!arraySaved.isize)
				arraySaved = intsArray(todo);
			array = arraySaved;
		} else
			array = intsArray(todo);
		d.writeCallback(d.data, array, linkSector << 6, 0, todo);
		linkSector += todo >> 6;
	}

	parts[0].volume[sectorsInode | 3] = nSector - 1;
	applyChanges(d, 0, sectorsInode + 3, sectorsInode + 4);

	return ("", newSector, newNLevels);
};

(volatile stateful any dfsObj, volatile stateful any data, const (volatile stateful any data, const stateful int volume[], int begin, int changeBegin, int changeEnd) -> () writeCallback,
		int inode, int size, int time) -> (const char error[], int begin, int end) resizeFile = {
	dfsImpl impl;
	char err[] = convertObjToImpl(impl, dfsObj, "resizeFile");
	if (err.csize) return (err, 0, 0);

	inode <<= 2;

	dfsPart parts[] = impl.data.parts;
	int volume[], inodeBegin, inodeEnd, i;

	for (i = 0; i < parts.lsize && (inode < inodeBegin || inode + 4 > inodeEnd); i += 1)
		volume = parts[i].volume, inodeBegin = parts[i].begin, inodeEnd = inodeBegin + volume.isize;

	if (inode < inodeBegin || inode + 4 > inodeEnd)
		return (mkError("need more volume data", "resizeFile"), inode, inode + 4);

	int nPart = i - 1, pos = inode - inodeBegin;

	if ((volume[pos] & 0xff) != DFS_INODE_FILE)
		return (mkError("inode is not a file", "resizeFile"), 0, 0);

	resizeFileData d = {writeCallback, data, impl};
	int changeBegin = 2, changeEnd = 2;

	if (!(volume[pos] >> 16 && 0xff)) {
		int dfstime = impl.methods.time2dfsTime(time);
		if (dfstime != volume[pos | 2]) {
			volume[pos | 2] = dfstime;
			changeEnd = 3;
		}
	}

	if (size != volume[pos | 1]) {
		changeBegin = 1;

		if (size > -(-volume[pos | 1] & -0x200)) {
			int maxsize, oldSector = volume[pos | 3], oldLevel = volume[pos] >> 24 & 0xff;

			(err, maxsize) = getMaxSize(d, oldSector, oldLevel);
			if (err.csize)
				return (err, maxsize, maxsize + 0x40);

			maxsize <<= 3;

			if (size > maxsize) {
				int newSector, newLevel;
				(err, newSector, newLevel) = resizeFileTree(d, oldSector, maxsize, size);
				if (err.csize)
					return (err, 0, 0);

				if (newLevel != oldLevel) {
					volume[pos] &= ~(0xff << 24);
					volume[pos] |= newLevel << 24;
					changeBegin = 0;
				}

				if (newSector != oldSector) {
					volume[pos | 3] = newSector;
					changeEnd = 4;
				}
			}
		}

		volume[pos | 1] = size;
	}

	if (changeEnd > changeBegin)
		applyChanges(d, nPart, pos + changeBegin, pos + changeEnd);

	return ("", 0, 0);
};
