/* dfs class, listCatalogue method implementation, T18.833-T18.915; $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "dfs.dpvmake"

type listCatalogueData = {
	volatile stateful dfsImpl impl;
	const (volatile stateful any data, const char fileName[], const dfsFileAttributes attr, const char error[]) -> () callback;
	volatile stateful any data;
	int begin;
	int end;
	int count;
};

(volatile stateful listCatalogueData d, volatile stateful int unicode[], volatile stateful int volume[], int inodeBegin, int inode)
        -> (int finish) reportItem = {
    if (d.count >= d.end)
        return 1;
    if (d.count < d.begin) {
        d.count += 1;
        return d.count >= d.end;
    }
    d.count += 1;

    char name[];
    int i, size = unicode.isize;
    for (i = 0; i < size; i += 1) {
	int uni = unicode[i];
	if ((uni & 0xFC00) == 0xD800 && i + 1 < size && (unicode[i + 1] & 0xFC00) == 0xDC00) {
		i += 1;
		uni = ((uni & 0x3ff) << 10 | (unicode[i] & 0x3ff)) + 0x10000;
	}
	printutf8(name, uni);
    }

    int ind = (inode - inodeBegin) << 2;
    int iType = volume[ind] & 0xff;

    dfsFileAttributes attr;
    attr.inode = inode;
    if (iType == 1)
        attr.mode = DFS_IFREG;
    else if (iType == 2)
        attr.mode = DFS_IFDIR;
    attr.size = volume[ind | 1];
    if (!(volume[ind] >> 16 & 0xff))
	attr.mtime = d.impl.methods.dfsTime2Time(volume[ind | 2]);

    d.callback(d.data, name, attr, "");

    return d.count >= d.end;
};

(volatile stateful any dfsObj, volatile stateful any data,
        const (volatile stateful any data, const char fileName[], const dfsFileAttributes attr, const char error[]) -> () callback,
        int inode, int begin, int end) -> (const char error[], int inode, int nextBegin) listCatalogue = {
    dfsImpl impl;
    char err[] = convertObjToImpl(impl, dfsObj, "listCatalogue");
    if (err.csize) return (err, 0, 0);

    listCatalogueData d = {impl, callback, data, begin, end};
    dfsPart parts[] = impl.data.parts;

    if (!parts.lsize)
        return (mkError("volume not added", "listCatalogue"), 0, 0);

    int volume[], inodeBegin, inodeEnd, unicode[], stack[], nbits, start = 1, finish;

    do {    
        if (inode < inodeBegin || inode >= inodeEnd) {
            int i;
            for (i = 0; i < parts.lsize && (inode < inodeBegin || inode >= inodeEnd); i += 1)
                volume = parts[i].volume, inodeBegin = parts[i].begin >> 2, inodeEnd = inodeBegin + (volume.isize >> 2);

            if (inode < inodeBegin || inode >= inodeEnd)
                return (mkError("need more volume parts", "listCatalogue"), inode, d.count);
        }

        int ind = (inode - inodeBegin) << 2, iHead = volume[ind] & 0xffffffff, iType = iHead & 0xff;

        if (start) {
            if (iType != 2)
                return (mkError("item is not a catalogue", "listCatalogue"), inode, 0);

            if (iHead >> 24 & 0xff) {
                if (iHead >> 28 != 1 || volume[ind | 3] >> 60)
                    return (mkError("invalid inode of type 2 in volume", "listCatalogue"), inode, 0);
                inode = volume[ind | 3] << 4 | iHead >> 24 & 0xf;
                start = 0;
            } else
                finish = 1;

        } else if (iType == DFS_INODE_NAME || iType == DFS_INODE_TRIE_FULL || iType == DFS_INODE_TRIE_PART) {
            int inodes[], u[], i;

            for (i = 1; i < 4; i += 1) {
                int t = iHead >> (i << 3) & 0xff, n = volume[ind | i];
                if (t >> 4 == 1) {
                    if (n >> 60)
                        return (mkError("invalid inode of type 8/E/F in volume (1)", "listCatalogue"), inode, 0);
                    inodes.ipush(n << 4 | t & 0xf);

                } else if (t >> 4 == 0) {
                    if (n) {
                        u.ipush(n & 0xffff);
                        u.ipush(n >> 16 & 0xffff);
                        u.ipush(n >> 32 & 0xffff);
                        u.ipush(n >> 48 & 0xffff);
                    }

                } else
                    return (mkError("invalid inode of type 8/E/F in volume (2)", "listCatalogue"), inode, 0);
            }

            if (inodes.isize < (iType != DFS_INODE_NAME) || inodes.isize > 2)
                return (mkError("invalid inode of type 8/E/F in volume (3)", "listCatalogue"), inode, 0);

            int bits;
            if (iType == DFS_INODE_TRIE_PART || !inodes.isize) {
                while (u.isize && u[u.isize - 1] == 0xffff)
                    u.ipop(1);
                if (u.isize && iType == DFS_INODE_TRIE_PART) {
                    int last = u[u.isize - 1];
                    if (last == 0x7fff)
                        u.ipop(1);
                    else {
                        for (bits = 15; last & 1; last >>= 1, bits -= 1);
                        u[u.isize - 1] = last << (15 - bits);
                    }
                }
            }

            if (u.isize) {
                if (nbits & 0xf)
                    unicode.ipop(1);
                nbits &= -0x10;

                copyints(unicode, u, 0, u.isize);
                nbits += u.isize << 4;
                if (bits)
                    nbits += bits - 16;
            }

            if (!inodes.isize) {
                if (!stack.isize)
                    return (mkError("incorrect chain of type 8 nodes", "listCatalogue"), inode, 0);

                inode = stack[stack.isize - 2];
                stack.ipop(2);

            } else if (inodes.isize == 1) {
                inode = inodes[0];

            } else if ((iHead >> 12 & 0xf) == 1) {
                stack.ipush(inodes[1]);
                stack.ipush(nbits);
                inode = inodes[0];
            } else {
                if (!(nbits & 0xf))
                    unicode.ipush(0);
                nbits += 1;
                stack.ipush(inodes[1]);
                stack.ipush(-nbits);
                inode = inodes[0];
            }

        } else if (iType == DFS_INODE_FILE || iType == DFS_INODE_DIR) {
            if (nbits & 0xf)
                return (mkError("illegal catalogue", "listCatalogue"), inode, 0);

            finish = reportItem(d, unicode, volume, inodeBegin, inode);

            if (!finish) {
                if (stack.isize) {
                    inode = stack[stack.isize - 2];
                    nbits = stack[stack.isize - 1];
                    stack.ipop(2);

                    if (nbits >= 0)
                        unicode.ipop(unicode.isize - (nbits >> 4));
                    else {
                        nbits = -nbits;
                        int usize = -(-nbits & -0x10) >> 4;
                        unicode.ipop(unicode.isize - usize);
                        int bits = (usize << 4) - nbits;
                        usize -= 1;
                        unicode[usize] = (unicode[usize] >> bits | 1) << bits;
                    }
                 } else
                    finish = 1;
            }

        } else if (iType == DFS_INODE_VOLUME) {
            if ((iHead >> 20 & 0xf) != 1 || volume[ind | 2] >> 60)
                return (mkError("invalid inode of type 3 in volume", "listCatalogue"), inode, 0);
            inode = volume[ind | 2] << 4 | iHead >> 16 & 0xf;

        } else if (iType == DFS_INODE_ITEM) {
            if (iHead >> 24 & 0xff) {
                if (iHead >> 28 != 1 || volume[ind | 3] >> 60)
                    return (mkError("invalid inode of type 9 in volume (3)", "listCatalogue"), inode, 0);
                stack.ipush(volume[ind | 3] << 4 | iHead >> 24 & 0xf);
                stack.ipush(nbits);
            }

            if ((iHead >> 20 & 0xf) != 1 || volume[ind | 2] >> 60)
                return (mkError("invalid inode of type 9 in volume (2)", "listCatalogue"), inode, 0);
            stack.ipush(volume[ind | 2] << 4 | iHead >> 16 & 0xf);
            stack.ipush(nbits);

            if ((iHead >> 12 & 0xf) != 1 || volume[ind | 1] >> 60)
                return (mkError("invalid inode of type 9 in volume (1)", "listCatalogue"), inode, 0);
            inode = volume[ind | 1] << 4 | iHead >> 8 & 0xf;

        } else {
            return (mkError("invalid inode type in volume", "listCatalogue"), inode, 0);
        }

    } while (!finish);

    return ("", 0, 0);
};
