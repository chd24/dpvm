/* dfs class, add file demo, T19.212-T19.351; $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "../../../utils/utils.dpvmake"
#include "../dfs.dpvmake"

type addFileData = {
	volatile dfsClass dfsObj;
	const char volumePath[];
	const char filePath[];
	const char loadPath[];
	const dfsFileAttributes attr;
	volatile int runs[];
	volatile int volume[];
	int pos;
	int end;
	int flags;
	int loadPos;
};

(volatile stateful any d, const stateful int volume[], int begin, int changeBegin, int changeEnd) -> () writeCallback = {
	addFileData datas[];
	objcopyto(datas, {d});
	addFileData data = datas[0];

	if (data.flags & DFS_FLAG_DEBUG) {
		char mess[];
		printf(mess, "[writeCallback: begin=%X, changeBegin=%X, changeEnd=%X]\r\n", {begin, changeBegin, changeEnd});
		outputp("", "", mess);
	}

	char text[] = ints2chars(volume, changeBegin, changeEnd);

	writep("", "", data.volumePath, text, (begin + changeBegin) << 3);
	return;
};

(volatile stateful addFileData data, const char file[], int status) -> () loadVolumeCallback = {
	if (data.flags & DFS_FLAG_DEBUG) {
		char mess[];
		printf(mess, "[loadVolumeCallback(1): pos=%X, end=%X, file.csize=%X, status=%X]\r\n", {data.pos, data.end, file.csize, status});
		outputp("", "", mess);
	}

	if (data.runs.isize) {
		if (status <= 0) {
			char mess[];
			printf(mess, "Failed read from file %s, pos=%X, status=%d\r\n", {data.loadPath, data.loadPos, status});
			outputp("", "", mess);
			return;
		}

		writep("", "", data.volumePath, file, data.runs[data.pos]);
		data.runs[data.pos] += status;
		data.loadPos += status;
		if (data.runs[data.pos] >= data.runs[data.pos + 1]) {
			data.pos += 2;
			if (data.pos >= data.runs.isize)
				return;
		}

		read(code, data, data.loadPath, data.loadPos, data.runs[data.pos + 1] - data.runs[data.pos]);
		return;
	}

	if (status <= 0 || status & 7) {
		char mess[];
		printf(mess, "Failed loading dfs volume part, status=%d\r\n", {status});
		outputp("", "", mess);
		return;
	}

	int volume[] = chars2ints(file, 0, status);

	if (data.end) {
		if (data.volume.isize)
			copyints(data.volume, volume, 0, volume.isize);
		else
			data.volume = volume;

		if (data.volume.isize < data.end - data.pos) {
			read(code, data, data.volumePath, (data.pos + data.volume.isize) << 3, (data.end - data.pos - data.volume.isize) << 3);
			return;
		}

		volume = data.volume;
		data.end = 0;
		int newVolume[];
		data.volume = newVolume;
	}

	char error[] = data.dfsObj.methods.addVolumePart(data.dfsObj, volume, data.pos);
	if (error.csize) {
		char mess[];
		printf(mess, "%s\r\n", {error});
		outputp("", "", mess);
		return;
	}

	dfsFileAttributes attr;
	(attr, error) = data.dfsObj.methods.findPath(data.dfsObj, data.filePath);
	int inode = attr.inode;
	if (error.csize) {
		if (strstr(error, "need more") >= 0) {
			data.pos = (inode >> 15) << 17;
			read(code, data, data.volumePath, data.pos << 3, 0x100000);
			return;
		}

		if (strstr(error, "not found") < 0) {
			char mess[];
			printf(mess, "%s, inode=%X\r\n", {error, inode});
			outputp("", "", mess);
			return;
		}

		char dirPath[], name[];
		strcat(dirPath, data.filePath);
		if (!dirPath.csize) {
			char mess[];
			printf(mess, "Illegal file path '%s'\r\n", {dirPath});
			outputp("", "", mess);
			return;
		}

		while (dirPath.csize && dirPath[dirPath.csize - 1] != '/')
			dirPath.cpop(1);

		substrcat(name, data.filePath, dirPath.csize, data.filePath.csize);

		if (dirPath.csize > 1)
			dirPath.cpop(1);

		dfsFileAttributes dirAttr;
		(dirAttr, error) = data.dfsObj.methods.findPath(data.dfsObj, dirPath);
		int dirInode = dirAttr.inode;

		if (error.csize) {
			if (strstr(error, "need more") >= 0) {
				data.pos = (dirInode >> 15) << 17;
				read(code, data, data.volumePath, data.pos << 3, 0x100000);
				return;
			}

			char mess[];
			printf(mess, "%s, path='%s', inode=%X\r\n", {error, dirPath, dirInode});
			outputp("", "", mess);
			return;

		} else if ((dirAttr.mode & DFS_IFMT) != DFS_IFDIR) {
			char mess[];
			printf(mess, "Item is not a catalogue, mode=%X, inode=%X\r\n", {dirAttr.mode, dirInode});
			outputp("", "", mess);
			return;
		}

		(error, inode) = data.dfsObj.methods.addToCatalogue(data.dfsObj, data, writeCallback, name, "", data.attr, dirInode);

		if (error.csize) {
			if (strstr(error, "need more") >= 0) {
				data.pos = (inode >> 15) << 17;
				read(code, data, data.volumePath, data.pos << 3, 0x100000);
				return;
			}

			char mess[];
			printf(mess, "%s, inode=%X\r\n", {error, dirInode});
			outputp("", "", mess);
			return;
		}

		(attr, error) = data.dfsObj.methods.findPath(data.dfsObj, data.filePath);
		inode = attr.inode;
		if (error.csize) {
			if (strstr(error, "need more") >= 0) {
				data.pos = (inode >> 15) << 17;
				read(code, data, data.volumePath, data.pos << 3, 0x100000);
				return;
			}

			char mess[];
			printf(mess, "%s, inode=%X\r\n", {error, inode});
			outputp("", "", mess);
			return;
		}
	}

	if ((attr.mode & DFS_IFMT) != DFS_IFREG) {
		char mess[];
		printf(mess, "Item is not a file, mode=%X, inode=%X\r\n", {attr.mode, inode});
		outputp("", "", mess);
		return;
	}

	if (attr.size != data.attr.size) {
		int begin, end;
		(error, begin, end) = data.dfsObj.methods.resizeFile(data.dfsObj, data, writeCallback, inode, data.attr.size, data.attr.mtime);

		if (error.csize) {
			if (strstr(error, "need more") >= 0 && begin < end) {
				data.pos = begin >> 6 << 6;
				data.end = -(-end >> 6 << 6);
				read(code, data, data.volumePath, data.pos << 3, (data.end - data.pos) << 3);
				return;
			}
			char mess[];
			printf(mess, "%s, begin=%X, end=%X\r\n", {error, begin, end});
			outputp("", "", mess);
			return;
		}
	}

	int runs[], begin, end;
	(runs, error, begin, end) = data.dfsObj.methods.getFileRuns(data.dfsObj, inode, 0, (1 << 63) - 1);
	if (error.csize) {
		if (strstr(error, "need more") >= 0 && begin < end) {
			data.pos = begin >> 6 << 6;
			data.end = -(-end >> 6 << 6);
			read(code, data, data.volumePath, data.pos << 3, (data.end - data.pos) << 3);
			return;
		}
		char mess[];
		printf(mess, "%s, begin=%X, end=%X\r\n", {error, begin, end});
		outputp("", "", mess);
		return;
	}

	data.runs = runs;
	data.pos = 0;
	if (runs.isize)
		read(code, data, data.loadPath, data.loadPos, data.runs[1] - data.runs[0]);
	return;
};

(volatile stateful addFileData data, const any attrs) -> () getStat = {
	if (attrs.lsize != 1) {
		char mess[];
		printf(mess, "illegal result of mstat() for item %s\r\n", {data.loadPath});
		outputp("", "", mess);
		return;
	}

	dfsFileAttributes attr;
	objcopyto(attr, attrs.l[0]);

	if ((attr.mode & DFS_IFMT) != DFS_IFREG) {
		char mess[];
		printf(mess, "Item %s is not a file, mode=%X\r\n", {data.loadPath, attr.mode});
		outputp("", "", mess);
		return;
	}

	data.attr = attr;

	read(loadVolumeCallback, data, data.volumePath, 0, 0x100000);
	return;
};

(const char volumePath[], const char filePath[], const char loadPath[], int flags) -> () addFile = {
	dfsClass dfsObj = dfsCreate();

	dfsObj.methods.setFlags(dfsObj, flags);

	addFileData data = {dfsObj, volumePath, filePath, loadPath};
	data.flags = flags;

	mstat(getStat, data, loadPath, 0, 2);
	return;
};
