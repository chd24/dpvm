/* te viewer/editor, T18.319-T20.328; $DVS:time$ */

int _Z = 0;
#include "../../../common/sysParams.dpvmh"
#include "../../../common/taskFlags.dpvmh"
#include "../../stdlib/stdlib.dpvmake"
#include "../../utils/utils.dpvmake"
#include "../../input/demo/demo.dpvmake"
#include "../../math/rand/rand.dpvmake"
#include "../../math/crypto/crc32/crc32.dpvmake"
#include "../../math/crypto/base64/base64.dpvmake"
#include "../../math/crypto/dfs/dfs.dpvmake"
#include "version.dpvmh"
#include "commands/commands.dpvmake"

int SEC_T0_T1			= 31556952;
int SEC_2000_T0			= 133080623;
int SEC_1970_2000		= 946684800;

int extT5_337Signature[]	= {0xc6de4f4c, 0x2ab6a7d7, 0x7f3efd27, 0xffff7edf};
int extT18_319Signature[]	= {0xc6de4f4c, 0x2ab2a7d7, 0x7c3dfd27, 0xff7d7dff};

(int time) -> (int teTime) time2teTime {
	time -= (SEC_1970_2000 + SEC_2000_T0) * 1000000000;
	time >>= 1;
	time /= 1125; time <<= 10;
	time /= 1125; time <<= 10;
	time /= 1125; time <<= 1;
	time /= 5411;
	return time;
}

(int teTime) -> (int teTime) teTime2Time {
	teTime *= 5411 * 1125;
	teTime >>= 10;
	teTime *= 1125;
	teTime >>= 10;
	teTime *= 1125;
	teTime += (SEC_1970_2000 + SEC_2000_T0) * 1000000000;
	return teTime;
}

(const stateful any obj) -> (volatile randData r) obj2rand {
	randData r;
	randObj.initObj(r, obj);

	int i;
	for (i = 0; i < 6; i += 1)
		randObj.get(r);

	return r;
}

(volatile stateful int dst[], const stateful any obj) -> () getDfs2Hash {
	randObj.saveHash(dst, obj2rand(obj));
	return;
}

(volatile stateful teContext ctx, const stateful char password[], const stateful int sector0[]) -> () teContextInit {
	if (!ctx.crc32Ctx.isize) {
		int crcCtx[];
		ctx.crc32Init = crc32_init(crcCtx);
		ctx.crc32Ctx = crcCtx;
	}

	if (!ctx.extT5_337SignatureHash.isize) {
		int extT5_337SignatureHash[];
		getDfs2Hash(extT5_337SignatureHash, extT5_337Signature);
		ctx.extT5_337SignatureHash = extT5_337SignatureHash;
	}

	if (!ctx.extT18_319SignatureHash.isize) {
		int extT18_319SignatureHash[];
		getDfs2Hash(extT18_319SignatureHash, extT18_319Signature);
		ctx.extT18_319SignatureHash = extT18_319SignatureHash;
	}

	int dfsCtx[];

	if (password.csize) {
		int passwordHash[];
		getDfs2Hash(passwordHash, password);
		ctx.passwordHash = passwordHash;

		ctx.passwordSet = 1;
		dfsCtx = dfs_init(password);
	} else if (ctx.passwordSet)
		objcopyto(dfsCtx, ctx.dfsCtx);
	else
		return;

	if (sector0.isize) {
		dfs_set_data(dfsCtx, sector0);

		int dfsCtxHash[];
		getDfs2Hash(dfsCtxHash, dfsCtx);
		ctx.dfsCtxHash = dfsCtxHash;
	}

	ctx.dfsCtx = dfsCtx;

	return;
}

(volatile stateful char dst[], const stateful char name[], const stateful int array[]) -> () dumpArray {
	strcat(dst, "  ");
	strcat(dst, name);
	strcat(dst, " = {");

	int i;
	for (i = 0; i < array.isize; i += 1) {
		if (i)
			strcat(dst, ", ");
		printhex(dst, array[i], 16, 0);
	}

	strcat(dst, "}\r\n");
	return;
}

(volatile stateful char dst[], const stateful char name[], int value) -> () dumpValue {
	strcat(dst, "  ");
	strcat(dst, name);
	strcat(dst, " = ");
	printint(dst, value, 1);
	strcat(dst, "\r\n");
	return;
}

(volatile stateful char dst[], const stateful teContext ctx) -> () teContextDump {
	strcat(dst, "TE context dump:\r\n");
	dumpArray(dst, "passwordHash", ctx.passwordHash);
	dumpArray(dst, "  dfsCtxHash", ctx.dfsCtxHash);
	dumpValue(dst, " passwordSet", ctx.passwordSet);
	dumpValue(dst, "  sector0Pos", ctx.sector0Pos);
	return;
}

(const stateful teContext ctx, volatile stateful int data[], const stateful any metaData, int begin, int size, int stage) -> () dfs2CryptInts32 {
	int hashes[];
	copyints(hashes, ctx.passwordHash, 0, ctx.passwordHash.isize);
	copyints(hashes, ctx.dfsCtxHash, 0, ctx.dfsCtxHash.isize);
	getDfs2Hash(hashes, metaData);

	if (stage == 1)
		copyints(hashes, ctx.extT5_337SignatureHash, 0, 4);
	else
		copyints(hashes, ctx.extT18_319SignatureHash, 0, 4);

	randData r = obj2rand(hashes);

	int i;
	for (i = 0; i < size; i += 1)
		data[begin + i] ^= randObj.getLimited(r, 1 << 32);

	return;
}

(const stateful teContext ctx, volatile stateful int data[], const stateful any metaData, int begin, int size, int Nsector, int method) -> (int res) dfsEncryptInts32 {
	if (!ctx.passwordSet)
		return 0;

	if (method < 1 || method > 2)
		return -1;

	if (size <= 0 || size & 1)
		return -2;

	if (method == 2)
		dfs2CryptInts32(ctx, data, metaData, begin, size, 1);

	if (dfs_encrypt(ctx.dfsCtx, data, begin, size, Nsector))
		return -3;

	if (method == 2)
		dfs2CryptInts32(ctx, data, metaData, begin, size, 2);

	return 0;
}

(const stateful teContext ctx, volatile stateful int data[], const stateful any metaData, int begin, int size, int Nsector, int method) -> (int res) dfsDecryptInts32 {
	if (!ctx.passwordSet)
		return 0;

	if (method < 1 || method > 2)
		return -1;

	if (size <= 0 || size & 1)
		return -2;

	if (method == 2)
		dfs2CryptInts32(ctx, data, metaData, begin, size, 2);

	if (dfs_decrypt(ctx.dfsCtx, data, begin, size, Nsector))
		return -3;

	if (method == 2)
		dfs2CryptInts32(ctx, data, metaData, begin, size, 1);

	return 0;
}

(volatile int hashes[], const stateful teContext ctx, const stateful int file[], int pos) -> () extT18_319MakeHash {
	int h[];
	copyints(h, ctx.passwordHash, 0, ctx.passwordHash.isize);
	copyints(h, ctx.dfsCtxHash, 0, ctx.dfsCtxHash.isize);

	int entry[];
	int i;
	for (i = 0; i < 144; i += 1) {
		int n;
		if (i < 8 || i >= 16)
			n = file[pos + i];
		entry.ipush(n);
	}
	getDfs2Hash(h, entry);

	int N[];
	N.ipush(pos / 144);
	getDfs2Hash(h, N);

	for (i = 0; i < 8; i += 1) {
		int n;
		int p = (pos << 1) + 36 * ((i & 4) + 4);
		if (file.isize >= p + 144)
			n = file[p + 8 + ((i & 3) << 1)] | file[p + 9 + ((i & 3) << 1)] << 32;
		h.ipush(n);
	}

	getDfs2Hash(hashes, h);
	return;
}

(const stateful teContext ctx, const stateful int file[], int pos, int encrypted) -> (int extension, int sectorNo) teEntryTest {
	int extension;

	int i;
	int mask1;
	int mask2;
	for (i = 0; i < 4; i += 1) {
		if (file[pos + i] == extT5_337Signature[i])
			mask1 |= 1 << i;
		if (file[pos + i] == extT18_319Signature[i])
			mask2 |= 1 << i;
	}

	if (mask2 == 0xf)
		extension = 2;
	else if (mask1 == 0xf)
		extension = 1;
	else
		return (-1, -1);

	if (extension == 2) {
		if (encrypted <= 0) {
			if (encrypted < 0) {
				teContext ctx2;
				objcopyto(ctx2, ctx);
				int sector0[];
				copyints(sector0, file, pos + 16, pos + 144);
				teContextInit(ctx2, "", sector0);
				ctx = ctx2;
			}

			int hashes[];
			extT18_319MakeHash(hashes, ctx, file, pos);

			for (i = 0; i < 4; i += 1) {
				if (hashes[i] != (file[pos + 8 + (i << 1)] | file[pos + 9 + (i << 1)] << 32)) {
					if (encrypted < 0)
						return (2, -1);

					return (-2, -1);
				}
			}

			if (encrypted < 0)
				return (2, 0);
		}
	} else if (extension == 1) {
		if (crc32_finalize(ctx.crc32Ctx, crc32_addints32(ctx.crc32Ctx, file, pos, pos + 15, ctx.crc32Init)) != file[pos + 15])
			return (-3, -1);

		if (encrypted > 0 && crc32_finalize(ctx.crc32Ctx, crc32_addints32(ctx.crc32Ctx, file, pos + 16, pos + 144, ctx.crc32Init)) != file[pos + 14])
			return (-4, -1);
	}

	return (extension, file[pos + 12] | file[pos + 13] << 32);
}

(volatile stateful char dst[], const stateful teContext ctx, const stateful int file[], int pos) -> () teEntryInfo {
	int res;
	int sectorNo;
	int extension;

	(res, sectorNo) = teEntryTest(ctx, file, pos, 0);
	if (res >= 0)
		extension = res;
	else if (res == -2)
		extension = 2;
	else if (res == -1)
		extension = 0;
	else
		extension = 1;

	strcat(dst, "TE entry information:\r\n");

	strcat(dst, "  - format version:     ");
	if (extension == 2)
		strcat(dst, "T18.319\r\n");
	else if (extension == 1)
		strcat(dst, "T5.337\r\n");
	else
		strcat(dst, "TE 2003\r\n");

	strcat(dst, "  - format correct:     ");
	if (res >= 0)
		strcat(dst, "yes\r\n");
	else
		strcat(dst, "no\r\n");

	strcat(dst, "  - position in file:   ");
	printint(dst, pos / 144, 1);
	strcat(dst, " of total ");
	printint(dst, file.isize / 144, 1);
	strcat(dst, "\r\n");

	if (pos == ctx.sector0Pos)
		sectorNo = 0;

	strcat(dst, "  - logical sequence #: ");
	printhex(dst, sectorNo, 16, 0);
	strcat(dst, "\r\n");

	strcat(dst, "  - creation time:      ");
	if (extension) {
		int time;
		if (extension == 2)
			time = file[pos + 4] | file[pos + 5] << 32;
		else
			time = file[pos + 8] | file[pos + 9] << 32;
		strftime(dst, "%Y-%m-%d %H:%M:%S GMT\r\n", teTime2Time(time), 0);
	} else
		strcat(dst, "unknown");

	strcat(dst, "  - modification time:  ");
	if (extension) {
		int time;
		if (extension == 2)
			time = file[pos + 6] | file[pos + 7] << 32;
		else
			time = file[pos + 10] | file[pos + 11] << 32;
		strftime(dst, "%Y-%m-%d %H:%M:%S GMT\r\n", teTime2Time(time), 0);
	} else
		strcat(dst, "unknown");

	return;
}

(const stateful teContext ctx, volatile stateful int file[], const stateful any seed, int pos, int time, int create, int extension) -> () teEntryCorrect {
	int mtime = time2teTime(time);
	int mtime0 = mtime & 0xffffffff;
	int mtime1 = mtime >> 32;

	if (create) {
		int i;

		if (extension == 1 || pos == ctx.sector0Pos) {
			teContext ctx2;
			if (!ctx.passwordSet || !ctx.dfsCtxHash.isize) {
				objcopyto(ctx2, ctx);
				char pwd[];
				int sector0[];
				for (i = 0; i < 32; i += 1) {
					any seed2;
					seed2.lpush(seed);
					seed2.ipush(pos);
					seed2.ipush(time);
					seed2.ipush(i);
					getDfs2Hash(sector0, seed2);
					if (!ctx.passwordSet)
						pwd.cpush(sector0[i << 2] & 0x7f);
				}
				teContextInit(ctx2, pwd, sector0);
			} else
				ctx2 = ctx;

			for (i = 0; i < 3 || !(file[pos + 12] | file[pos + 13]); i += 1)
				dfsEncryptInts32(ctx2, file, seed, pos, 16 + (pos == ctx.sector0Pos) * 128, time, 2);
		}

		int signature[];

		if (extension == 2)
			signature = extT18_319Signature;
		else
			signature = extT5_337Signature;

		for (i = 0; i < 4; i += 1)
			file[pos + i] = signature[i];

		if (extension == 1 && pos) {
			for (i = 0; i < 4; i += 1)
				file[pos + 4 + i] = file[4 + i];

			if (pos == ctx.sector0Pos)
				file[pos + 12] = 0,
				file[pos + 13] = 0;
		}

		if (extension == 2)
			file[pos + 4] = mtime0,
			file[pos + 5] = mtime1;
		else
			file[pos + 8] = mtime0,
			file[pos + 9] = mtime1;
	}

	if (extension == 2)
		file[pos + 6] = mtime0,
		file[pos + 7] = mtime1;
	else
		file[pos + 10] = mtime0,
		file[pos + 11] = mtime1;

	if (extension == 2) {
		int shift = 1;

		if (pos == ctx.sector0Pos) {
			shift = 0;
			pos = file.isize - 144;
		}

		int n;
		for (n = pos / 144; n + 1 > 0; n = (n - 1) >> shift) {
			pos = n * 144;

			int hashes[];
			extT18_319MakeHash(hashes, ctx, file, pos);

			int i;
			for (i = 0; i < 4; i += 1) {
				file[pos + 8 + (i << 1)] = hashes[i] & 0xffffffff;
				file[pos + 9 + (i << 1)] = hashes[i] >> 32;
			}
		}
	} else {
		int arr[];
		copyints(arr, file, pos + 16, pos + 144);
		if (pos != ctx.sector0Pos)
			dfsEncryptInts32(ctx, arr, "", 0, 128, file[pos + 12] | file[pos + 13] << 32, 1);

		file[pos + 14] = crc32_finalize(ctx.crc32Ctx, crc32_addints32(ctx.crc32Ctx, arr, 0, 128, ctx.crc32Init));
		file[pos + 15] = crc32_finalize(ctx.crc32Ctx, crc32_addints32(ctx.crc32Ctx, file, pos, pos + 15, ctx.crc32Init));
	}

	return;
}

teUtilities teUtilitiesObj = {
	teVersion,
	teCommands,
	teContextInit,
	teContextDump,
	dfsEncryptInts32,
	dfsDecryptInts32,
	teEntryTest,
	teEntryInfo,
	teEntryCorrect,
	time2teTime,
	teTime2Time
};

(const teData data, const char mess[]) -> () fatalError {
	char m[];
	strcat(m, teVersion);
	strcat(m, ": fatal error: ");
	strcat(m, mess);
	strcat(m, ".\r\n");
	outputp("", "", m);
	msendp("", "", data.addr, "");
	return;
}

(volatile stateful teData data, const char text[]) -> (const char result[]) processOne {
	int begin;
	int end;
	(begin, end) = strtostr(text, 0, text.csize);

	if (begin >= end)
		return "No command.\r\n";

	char cmd[];
	substrcat(cmd, text, begin, end);

	int i;
	for (i = 0; i < teCommands.lsize; i += 1) {
		if (cmd == teCommands[i].name) {
			return teCommands[i].command(data);
		}
	}

	return "Unknown command.\r\n";
}

(volatile teData data, const char text[], int status) -> () processCommand {
	if (status < 0) {
		fatalError(data, "input error");
		return;
	}

	do {
		text = processOne(data, text);
	} while (!text.csize || text[text.csize - 1] != '\n');

	output(data.command, data, text);
	return;
}

(volatile stateful any d, const char text[], int status) -> () processCommandHelper = {
	teData arr[];
	pushObject(d, arr);
	return processCommand(arr[0], text, status);
};

(volatile teData data, int status) -> () command {
	outputp("", "", "te> ");
	inputExt(processCommandHelper, data, 256, -1);
	return;
}

(volatile teData data, const char text[], int status) -> () processPassword {
	if (status < 0) {
		fatalError(data, "input error");
		return;
	}

	while (status && (text[status - 1] == '\r' || text[status - 1] == '\n'))
		status -= 1;

	char pwd[];
	substrcat(pwd, text, 0, status);

	int Nsectors[];
	int sector0[];
	int sector0Pos = -1;

	teContext ctx;
	teContextInit(ctx, pwd, sector0);

	if (status && data.file.isize) {
		int Nsector;
		int res;

		(res, Nsector) = teEntryTest(ctx, data.file, 0, 1);

		if (res < 0) {
			char mess[];
			strcat(mess, "file '");
			strcat(mess, data.filename);
			strcat(mess, "' has unknown extension format (error ");
			printint(mess, res, 1);
			strcat(mess, ")");
			fatalError(data, mess);
			return;
		}

		Nsectors.ipush(Nsector);
		data.extension = res;

		int i;
		for (i = 144; i < data.file.isize; i += 144) {
			(res, Nsector) = teEntryTest(ctx, data.file, i, sector0Pos);

			if (res != data.extension) {
				char mess[];
				strcat(mess, "file '");
				strcat(mess, data.filename);
				strcat(mess, "' contains entry #");
				printint(mess, i / 144, 1);
				strcat(mess, " not matched TE extension format (error ");
				printint(mess, res, 1);
				strcat(mess, " in encrypted mode)");
				fatalError(data, mess);
				return;
			}

			if (!Nsector && sector0Pos < 0)
				sector0Pos = i;

			Nsectors.ipush(Nsector);
		}

		if (sector0Pos < 0) {
			char mess[];
			strcat(mess, "file '");
			strcat(mess, data.filename);
			strcat(mess, "' do not contain entry with sequence number 0");
			fatalError(data, mess);
			return;
		}

		copyints(sector0, data.file, sector0Pos + 16, sector0Pos + 144);
		teContextInit(ctx, "", sector0);
		ctx.sector0Pos = sector0Pos;

		int n;
		for (i = 0; i < data.file.isize; i += 144, n += 1)
			if (i != sector0Pos) {
				int metaData[];
				copyints(metaData, data.file, i, i + 16);
				dfsDecryptInts32(ctx, data.file, metaData, i + 16, 128, Nsectors[n], data.extension);
			}
	}

	if (!data.file.isize) {
		data.extension = 2;
		ctx.sector0Pos = 144;
	}

	data.ctx = ctx;

	int i;
	for (i = 0; i < data.file.isize; i += 144) {
		int Nsector;
		int res;
		(res, Nsector) = teEntryTest(ctx, data.file, i, 0);

		if (!data.extension && res > 0)
			data.extension = res;

		if (res != data.extension) {
			char mess[];
			strcat(mess, "file '");
			strcat(mess, data.filename);
			strcat(mess, "' contains entry #");
			printint(mess, i / 144, 1);
			strcat(mess, " not matched TE extension format (error ");
			printint(mess, res, 1);
			strcat(mess, " in uncrypted mode)");
			fatalError(data, mess);
			return;
		}

		int j;
		for (j = 0; j < 4; j += 1) {
			int index = i / 36 + j;
			int field[];
			copyints(field, data.file, i + j * 32 + 16, i + j * 32 + 48);

			int found;
			any oldIndexObj;
			if (field != data.emptyField) {
				(oldIndexObj, found) = hashObj.findGetValue(data.hash, field);
				if (!found) {
					int indexObj[];
					indexObj.ipush(index);
					hashObj.findAddKeyValue(data.hash, field, indexObj);
				}
			}

			if (found) {
				int indexNext = oldIndexObj.i[0];
				int indexPrev = data.prevIndexes[indexNext];
				data.nextIndexes[indexPrev] = index;
				data.prevIndexes[indexNext] = index;
				data.prevIndexes.ipush(indexPrev);
				data.nextIndexes.ipush(indexNext);
			} else {
				data.prevIndexes.ipush(index);
				data.nextIndexes.ipush(index);
			}
		}
	}

	const int vars[] = {DPVM_SYS_PARAM_FLAGS};
	const int values[] = {DPVM_TASK_FLAG_NO_INPUT_HISTORY};
	setsysp("", "", vars, values);

	output(command, data, "Type 'help' for commands list.\r\n");
	return;
}

(volatile stateful any d, const char text[], int status) -> () processPasswordHelper = {
	teData arr[];
	pushObject(d, arr);
	return processPassword(arr[0], text, status);
};

(volatile teData data, const char file[], int status) -> () readFile {
	if (status < 0 || status % (66 * 12)) {
		char mess[];
		strcat(mess, "file '");
		strcat(mess, data.filename);
		strcat(mess, "' has illegal length");
		fatalError(data, mess);
		return;
	}

	char decoded[];
	int res = base64_decode_str(decoded, file, 0);
	if (decoded.csize != status / (66*12) * 576 || res & 0xf) {
		char mess[];
		strcat(mess, "file '");
		strcat(mess, data.filename);
		strcat(mess, "' has illegal format (");
		printint(mess, status / (66*12) * 576, 1);
		strcat(mess, " base64 decoded bytes expected from file size ");
		printint(mess, status, 1);
		strcat(mess, ", ");
		printint(mess, decoded.csize, 1);
		strcat(mess, " bytes decoded)");
		fatalError(data, mess);
		return;
	}

	data.file = chars2ints32(decoded, 0, decoded.csize);

	const int vars[] = {DPVM_SYS_PARAM_FLAGS};
	int values[] = {DPVM_TASK_FLAG_NO_INPUT_HISTORY | DPVM_TASK_FLAG_NO_INPUT_ECHO};
	setsysp("", "", vars, values);

	outputp("", "", "Password: ");

	inputExt(processPasswordHelper, data, 256, -1);
	return;
}

(const teData cdata, const any objs, int status) -> () checkAddress {
	if (status) {
		fatalError(cdata, "address is still in use, kill previous program");
		return;
	}

	teData data;
	data.filename = cdata.filename;
	data.addr = cdata.addr;
	data.command = command;
	data.utilities = teUtilitiesObj;
	hashObj.initExt(data.hash, 0x1000, hashFlagKeyValue);

	int emptyField[];
	int i;
	for (i = 0; i < 32; i += 1)
		emptyField.ipush(0xffffffff);
	data.emptyField = emptyField;

	read(readFile, data, data.filename, 0, 0x100000);
	return;
}

(const char filename[]) -> () teOpen {
	char mess[];
	strcat(mess, teVersion);
	strcat(mess, " (");
	printobjname(mess, code);
	strcat(mess, ")\r\n");
	outputp("", "", mess);

	teData data;
	data.filename = filename;

	teAddr addr;
	addr.extVersion = mess;
	addr.filename = filename;
	data.addr = addr;

	mrecvp("", "", addr, 0);
	mrecvp(checkAddress, data, addr, 0);
	mrecvp("", "", addr, -1);

	return;
}

/* te viewer/editor */
teClass teObj = {
	teUtilitiesObj,
	teOpen
};
