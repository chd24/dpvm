/* dpvmb class, methods implementation, T20.127-T20.155; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.2, T19.354-T20.056 */

#include "../../../../tools/registry/registry.dpvmake"
#include "../../../../lib/stdlib/stdlib.dpvmake"
#include "dpvmb.dpvmake"
#include "version.dpvmh"

int registryMask = REGISTRY_CHECKER + REGISTRY_TRANSLATOR;	/* mask of registry applications used by dpvmb class */

(volatile stateful any dpvmbObj) -> (const char error[], int flags) getFlags = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any dpvmbObj, int flags) -> (const char error[]) setFlags = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any dpvmbObj, const stateful any registry) -> (const char error[]) setRegistry = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(volatile stateful any dpvmbObj, const char fileName[]) -> (const char error[]) setFileName = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "setFileName");
	if (err.csize) return err;

	impl.data.fileName = fileName;
	impl.data.fileNameSet = 1;
	impl.data.savedBytes = 0;
	return "";
};

(volatile stateful any dpvmbObj) -> (const char error[]) save = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "save");
	if (err.csize) return err;

	if (!impl.data.fileNameSet)
		return mkError("filename not set", "save");

	if (!impl.data.dbInited)
		return mkError("database not initialized", "save");

	if (impl.data.savedBytes < impl.data.db.csize) {
		char text[];
		substrcat(text, impl.data.db, impl.data.savedBytes, impl.data.db.csize);
		writep("", "", impl.data.fileName, text, impl.data.savedBytes);
		impl.data.savedBytes = impl.data.db.csize;
		writep("", "", impl.data.fileName, "", impl.data.savedBytes);
	}

	return "";
};

(volatile stateful any dpvmbObj, const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data) -> () load = {
	dpvmbImpl impl;
	char err[] = convertObjToImpl(impl, dpvmbObj, "load");
	if (err.csize) return callback(data, err);

	if (!impl.data.fileNameSet)
		return callback(data, mkError("filename not set", "load"));

	const type loadData = {
		volatile dpvmbImpl impl;
		const (volatile stateful any data, const char error[]) -> () callback;
		volatile stateful any data;
	};

	const (volatile stateful loadData d, const char text[], int status) -> () loadCallback = {
		if (text.csize)
			strcat(d.impl.data.db, text), d.impl.data.savedBytes = d.impl.data.db.csize;
		if (status == 0x100000)
			read(code, d, d.impl.data.fileName, d.impl.data.db.csize, 0x100000);
		return d.callback(d.data, status < 0 ? mkError("file loading failed", "load") : "");
	};

	impl.data.db = (volatile char[]){};
	impl.data.dbInited = 0;
	impl.data.savedBytes = 0;
	impl.data.archiver = (Archiver){};
	return loadCallback((loadData){impl, callback, data}, "", 0x100000);
};

dpvmbMethods dpvmbMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setRegistry,
	setFileName,
	dump,
	selfArchiver,
	makeFirstObj,
	verify,
	new,
	save,
	load,
	add,
	find,
	store,
	restore
};
