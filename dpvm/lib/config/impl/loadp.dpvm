/* config class, dump method implementation, T20.056-T20.219; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.2, T19.354-T20.056 */

int _Z = 0;
#include "../../../common/sysParams.dpvmh"
#include "../../../lib/stdlib/stdlib.dpvmake"
#include "../../../lib/utils/utils.dpvmake"
#include "../../../tools/registry/registry.dpvmh"
#include "../../../app/net/p2p/p2p_io.dpvmake"
#include "config.dpvmake"

int READ_SIZE	 = 0x100000;
int LOAD_TIMEOUT = 10000000000;

type constLoadpData = {
	const any configObj;
	const configImpl impl;
	const (const any config, const char error[]) -> () callback;
	const char configTypeName[];
};

type loadpData = {
	const constLoadpData cd;
	volatile configFile files[];
	volatile char text[];
	const int hashes[];
	int time;
	int taskid;
	int fileNo;
};

(const stateful loadpData d) -> () makeConfig = {
	char text[];

	printf(text, "/* generated by %s */\r\n\r\n", {d.cd.impl.methods.version});

	int i;
	for (i = 0; i < d.files.lsize; i += 1) {
		if (!(d.files[i].flags & FILE_CONFIG))
			printf(text, "#include \"%s\"\r\n", {d.files[i].filename});
	}

	strcat(text,  "\r\nany __CONFIG__   = "); printobjname(text, d.cd.configObj);
	strcat(text, ";\r\nany __FUNCTION__ = "); printobjname(text, d.cd.impl.data.function);
	strcat(text, ";\r\nany __REGISTRY__ = "); printobjname(text, d.cd.impl.data.registry);
	printf(text, ";\r\nint __TASKID__   = %d", {d.taskid});
	printf(text, ";\r\nint __TIME__     = %d", {d.time});
	strcat(text, ";\r\n\r\n() -> (const any config) _generateConfig_ = {\r\n");
	printf(text, "\t%s _config_;\r\n", {d.cd.configTypeName});
	any objs = {d.cd.configObj, d.cd.impl.data.function, d.cd.impl.data.registry};

	for (i = 0; i < d.files.lsize; i += 1) {
		if (d.files[i].flags & FILE_CONFIG) {
			char file[] = d.files[i].file;
			int j, size = file.csize, state; /* 0 - newline, 1 - was nonspace, 2 - first was identifier */
			for (j = 0; j <= size; j += 1) {
				int c = '\n';
				if (j < size) c = file[j];
				if (c == '\n' || c == '\r') {
					if (state == 2)
						text.cpush(';');
					if (state && c == '\n')
						text.cpush('\r');
					state = 0;
				} else if (state == 0) {
					if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_') {
						strcat(text, "\t_config_.");
						state = 2;
					} else if (c != ' ' && c != '\t')
						state = 1;
				}
				text.cpush(c);
			}

			for (j = 0; j < d.files[i].objects.lsize; j += 1)
				objs.lpush(d.files[i].objects.l[j]);
		}
	}

	printf(text, "\treturn _config_;\r\n}", {});

	compsrc src0 = {"[_generateConfig_]", text, objs};
	compsrc srcs[] = {src0};

	for (i = 0; i < d.files.lsize; i += 1) {
		if (!(d.files[i].flags & FILE_CONFIG)) {
			compsrc src = {d.files[i].filename, d.files[i].file, d.files[i].objects};
			srcs.lpush(src);
		}
	}

	any func = d.cd.impl.data.registry.compiler.compile(d.cd.impl.data.registry, srcs);
	if (func.type == "".type) {
		char errs[][];
		pushObject(func, errs);
		if (d.cd.impl.data.flags & CONFIG_FLAG_DEBUG) {
			outputp("", "", "Config generating function which compilation is failed:\r\n");
			outputp("", "", "----------------------------------------------------------\r\n");
			outputp("", "", text);
			outputp("", "", "----------------------------------------------------------\r\n");
		}
		return d.cd.callback({}, errs[0]);
	}

	const type getConfig = () -> (const any config);
	if (func.type != getConfig)
		return d.cd.callback({}, mkError("illegal type of compiled function", "loadp:makeConfig"));

	getConfig funcs[];
	pushObject(func, funcs);
	return d.cd.callback(funcs[0](), "");
};

(volatile stateful loadpData d, const any objs) -> () loadCallback = {
	if (d.fileNo >= 0) {
		int i, h[] = d.hashes;
		for (i = 0; i < objs.lsize; i += 1) {
			int x, y, z, t, j = 4 * i, X = h[j], Y = h[j + 1], Z = h[j + 2], T = h[j + 3];
			(x, y, z, t) = getfullhash(objs.l[i]);
			if (!(x == X && y == Y && z == Z && t == T || x << 17 >> 17 == X && Y == 0 && Z == 0 && T == 0)) {
				char err[], objname[];
				printobjname(objname, X << 17 >> 17);
				printf(err, "object %s in file '%s' not found", {objname, d.files[d.fileNo].filename});
				return d.cd.callback({}, mkError(err, "loadp:loadCallback"));
			}
		}

		d.files[d.fileNo].objects = objs;
		d.files[d.fileNo].flags |= FILE_OBJECTS;
	}

	do {
		d.fileNo += 1;
		if (d.fileNo < d.files.lsize && !(d.files[d.fileNo].flags & FILE_OBJECTS)) {
			d.hashes = text2hashes(d.files[d.fileNo].file);
			if (!d.hashes.isize)
				d.files[d.fileNo].flags |= FILE_OBJECTS;
		}
	} while (d.fileNo < d.files.lsize && d.files[d.fileNo].flags & FILE_OBJECTS);

	if (d.fileNo < d.files.lsize)
		mload_p2p(code, d, d.hashes, LOAD_TIMEOUT);
	else
		makeConfig(d);

	return;
};

(volatile stateful loadpData d, const char body[], int status) -> () readCallback = {
	if (status < 0) {
		char err[];
		printf(err, "file '%s' reading error", {d.files[d.fileNo].filename});
		return d.cd.callback({}, mkError(err, "loadp:readCallback"));
	}

	if (body.csize) {
		strcat(d.text, body);
	}

	if (status == READ_SIZE) {
		read(code, d, d.files[d.fileNo].filename, d.text.csize, READ_SIZE);
		return;
	}

	if (d.fileNo >= 0) {
		if (!d.text.csize) {
			char err[];
			printf(err, "file '%s' not found or empty", {d.files[d.fileNo].filename});
			return d.cd.callback({}, mkError(err, "loadp:readCallback"));
		}

		d.files[d.fileNo].file = d.text;
		d.files[d.fileNo].flags |= FILE_LOADED;
		char text[];
		d.text = text;
	}

	do
		d.fileNo += 1;
	while (d.fileNo < d.files.lsize && d.files[d.fileNo].flags & FILE_LOADED);

	if (d.fileNo < d.files.lsize) {
		read(code, d, d.files[d.fileNo].filename, 0, READ_SIZE);
		return;
	}

	d.fileNo = -1;
	loadCallback(d, {});
	return;
};

(const constLoadpData cd, const int values[]) -> () getsysCallback = {
	configFile files[];
	int i;
	for (i = 0; i < cd.impl.data.files.lsize; i += 1) {
		configFile file;
		objcopyto(file, cd.impl.data.files[i]);
		files.lpush(file);
	}

	char text[];
	int hashes[];
	loadpData d = {cd, files, text, hashes, values[0], values[1], -1};
	readCallback(d, "", 0);
	return;
};

(const constLoadpData cd, const any objs, int status) -> () checkAddress = {
	if (status) {
		cd.callback({}, mkError("address is still in use, kill previous program", "loadp:checkAddress"));
		return;
	}

	const int vars[] = {DPVM_SYS_PARAM_TIME, DPVM_SYS_PARAM_ID};
	getsys(getsysCallback, cd, vars);
	return;
};

(const any configObj, const (const any config, const char error[]) -> () callback,
		const char configTypeName[]) -> () loadp = {
	configImpl impl;
	char err[] = convertObjToImpl(impl, configObj, "loadp");
	if (err.csize) return callback({}, err);

	if (!impl.data.registrySet)
		return callback({}, mkError("registry is not set", "loadp"));

	constLoadpData cd = {configObj, impl, callback, configTypeName};

	if (impl.data.flags & CONFIG_FLAG_INPUT) {
		mrecvp("", "", impl, 0);
		mrecvp(checkAddress, cd, impl, 0);
		mrecvp("", "", impl, -1);
		mrecvp("", "", impl, 1 << 63);
	} else {
		const int vars[] = {DPVM_SYS_PARAM_TIME, DPVM_SYS_PARAM_ID};
		getsysp(getsysCallback, cd, vars);
	}

	return;
};
