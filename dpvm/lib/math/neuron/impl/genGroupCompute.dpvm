/* neuron class */
char methodVersion[] = "genGroupCompute() internal method, T19.484-T19.739"; /* $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "neuron.dpvmake"

(volatile stateful char s[], neuronLayer layers[], int layerId, int groupId, int mode) -> () outParameters = {
	printf(s, "(volatile stateful float %c[%d]", {layers[layerId].groups[groupId].nOutputs, "op"[mode & 1]});
	if (!(mode & 2)) {
		if (mode & 1)
			printf(s, ", const stateful float o[%d]", {layers[layerId].groups[groupId].nOutputs});

		int i;
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'a' + i;
			printf(s, ", const stateful float %c[%d]",
					{layers[layerId + ((mode & 1) << 1) - 1].groups[i].nOutputs, c});
		}
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'q' + i;
			printf(s, ", const stateful float %c[%d]",
					{layers[layerId + (mode & 1)].groups[i].nWeights * (mode >> 2), c});
		}
	}
	s.cpush(')');
	return;
};

(int mode) -> (const char s[]) getParameterNames = {
	char s[];
	printf(s, "(%c", {"op"[mode & 1]});
	if (!(mode & 2)) {
		if (mode & 1)
			strcat(s, ",o");

		int i;
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'a' + i;
			printf(s, ",%c", {c});
		}
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'q' + i;
			printf(s, ",%c", {c});
		}
	}
	s.cpush(')');
	return s;
};

(const stateful neuronDataCompile data, int layerId, int groupId, int mode) -> (const any func, int nSubroutines) genGroupCompute = {
	neuronNet net = data.net;
	neuronLayer layer = net.layers[layerId];
	neuronGroup group = layer.groups[groupId];
	any compute[];
	char stage[], name[], s[];

	if (mode) stage = "backpropagate";
	else stage = "compute";

	int coeff = 1;
	if (data.flags & NEURON_METHOD_RMSP)
		coeff = 3;
	else if (data.flags & NEURON_METHOD_MOMENTUM)
		coeff = 2;
	mode |= coeff << 2;

	/* generate source code for compute/backpropagate0 functions */

	int length, j;

	for (j = 0; j < group.neurons.lsize; j += 1) {
		int l;
		do {
			if (!length) {
				{
					char nam[];
					name = nam;
				}
				printf(name, "layer[%d].group[%d].%s%d", {stage, layerId, groupId, compute.lsize});
				asm { unfix };
				printf(s, "/* Source of %s, generated by %s */\r\n", {name, methodVersion});
				outParameters(s, net.layers, layerId, groupId, mode);
				strcat(s, " ->\r\n");
				outParameters(s, net.layers, layerId, groupId, mode);
				printf(s, "\r\n\t\t%s%d = {\r\n", {stage, compute.lsize});
				length = s.csize;
			}

			asm { unfix };
			l = genNeuronCompute(s, data, layerId, groupId, j, mode & 1, l);

			if (l != -1 || j == group.neurons.lsize - 1 || s.csize >= SOURCE_MAX) {
				if (s.csize > length) {
					printf(s, "\treturn %s;\r\n};\r\n", {getParameterNames(mode)});
					any func = compile(data, name, s, {});
					if (func.type == "".type) {
						return (func, -1);
					}
					compute.lpush(func);
				}
				asm { unfix };
				s.cpop(s.csize);
				length = 0;
			}
		} while (l != -1);
	}


	/* generate source code for group compute/backpropagate function */

	{
		char nam[];
		name = nam;
	}
	printf(name, "layer[%d].group[%d].%s", {stage, layerId, groupId});
	asm { unfix };
	printf(s, "/* Source of %s, generated by %s */\r\n", {name, methodVersion});
	outParameters(s, net.layers, layerId, groupId, mode);
	strcat(s, " ->\r\n");
	outParameters(s, net.layers, layerId, groupId, mode + 2);
	printf(s, "\r\n\t\t%s = {\r\n", {stage});
	any links;

	int i;
	for (i = 0; i < compute.lsize; i += 1) {
		printf(s, "\t%p%s;\r\n", {compute[i], getParameterNames(mode)});
		links.lpush(compute[i]);
	}

	printf(s, "\treturn %s;\r\n};\r\n", {getParameterNames(mode + 2)});


	/* compile compute function */

	return (compile(data, name, s, links), compute.lsize);
};
