/* neuron class, methods implementation, T19.358-T19.683; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.0, T19.354-T19.358 */

#include "neuron.dpvmake"
#include "version.dpvmh"

(volatile stateful any neuronObj) -> (const char error[], int flags) getFlags = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.cdata.flags);
};

(volatile stateful any neuronObj, int flags) -> (const char error[]) setFlags = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "setFlags");
	if (err.csize) return err;

	impl.data.cdata.flags = flags;
	return "";
};

(volatile stateful any neuronObj, const any seed) -> (const char error[]) setRandomSeed = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "setRandomSeed");
	if (err.csize) return err;

	randObj.initObj(impl.data.rand, seed);
	return "";
};

(volatile stateful any neuronObj, const stateful any registryObj) -> (const char error[]) setRegistry = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "setRegistry");
	if (err.csize) return err;

	registryData registry;
	(registry, err) = registryPrepare(registryObj);
	if (err.csize) return err;

	impl.data.cdata.registry = registry;
	impl.data.cdata.registrySet = 1;
	return "";
};

(volatile stateful any neuronObj, const char name[]) -> (const activationFunction f, const char error[]) getActivationFunction = {
	activationFunction f;
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "getActivationFunction");
	if (err.csize) return (f, err);

	int i;
	for (i = 0; i < impl.methods.activationFunctions.lsize; i += 1)
		if (name == impl.methods.activationFunctions[i].name)
			return (impl.methods.activationFunctions[i], "");

	return (f, mkError("function not found", "getActivationFunction"));
};

(volatile stateful any neuronObj) -> (const char error[], int nInputs) getNInputs = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "getNInputs");
	if (err.csize) return (err, 0);

	if (!impl.data.cdata.net.layers.lsize)
		return (mkError("inputs not assigned to the net", "getNInputs"), 0);

	return ("", impl.data.cdata.net.layers[0].nNeurons);
};

(volatile stateful any neuronObj) -> (const char error[], int nOutputs) getNOutputs = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "getNOutputs");
	if (err.csize) return (err, 0);

	if (impl.data.cdata.net.layers.lsize < 2)
		return (mkError("outputs not assigned to the net", "getNOutputs"), 0);

	return ("", impl.data.cdata.net.layers[impl.data.net.layers.lsize - 1].nNeurons);
};

neuronMethods neuronMethodsImpl = {
	version,
	activationFunctions,
	getFlags,
	setFlags,
	setRandomSeed,
	setRegistry,
	getActivationFunction,
	construct,
	getNInputs,
	getNOutputs,
	training,
	dump
};
