/* neuron class, internal header, T19.358-T19.744; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.0, T19.354-T19.358 */

#include "../../../../tools/registry/registry.dpvmh"
#include "../../rand/rand.dpvmake"
#include "../neuron.dpvmh"

int NEURON_PARALLEL	= 6;
int SOURCE_MAX		= 0x20000; /* lenght of function source to cut it into several subroutines */
int SUBROUTINES_MAX	= 100; /* total number of subroutines in all groups to enforce parallel computattion */


/* one neuron */
type neuron = {
	volatile int inputNeuronIds[];			/* flat ids of input neurons */
	volatile int inputWeightIds[];			/* flat ids of input weights */
	volatile int outputNeuronIds[];			/* flat ids of output neurons */
	volatile int outputWeightIds[];			/* flat ids of output weights */
	const activationFunction activation;		/* function of activation for this neuron */
	int layerId;					/* layer id of neuron */
	int groupId;					/* group id of neuron */
	int outputStartId;				/* first position of neuron's output in group output */
	int nOutputs;					/* number of neuron outputs */
};

/* group of neurons from one layer computed in one parallel thread: compile-time data */
type neuronGroup = {
	volatile neuron neurons[];			/* array of neurons in this group */
	int neuronStartId;				/* flat id of first neuron from this group */
	int weightStartId;				/* flat id of first weight from this group */
	int nOutputs;					/* number of outputs in group */
	int nWeights;					/* number of weights in this group */
};

/* group of neurons from one layer computed in one parallel thread: run-time data */
type neuronGroupRuntime = {
	volatile any outputs;				/* {int[fixed]}; output values of neurons from this group */
	volatile any derivations;			/* {int[fixed]}; backpropaganda derivations for neurons from this group */
	volatile any weights;				/* {int[fixed]}; array of weights of edges from previous layer to this */
};

/* layer of neurons: compile-time data */
type neuronLayer = {
	volatile neuronGroup groups[NEURON_PARALLEL..];	/* array of groups within layer */
	volatile int inputNeuronIds[][];		/* array of arrays of input neurons for each weight parameter */
	volatile int outputNeuronIds[][];		/* array of arrays of output neurons for each weight parameter */
	int neuronStartId;				/* flat id of first neuron from this layer */
	int weightStartId;				/* flat id of first weight from this layer */
	int nNeurons;					/* number of neurons in this layer */
	int nWeights;					/* number of weights in this layer */
};

/* layer of neurons: run-time data */
type neuronLayerRuntime = {
	volatile neuronGroupRuntime groups[NEURON_PARALLEL..];	/* array of groups within layer */
};

type netTrainingFunc = (volatile stateful any data, volatile stateful float outputs[],
		const trainingParams params) -> (float res);

/* neuron net: compile-time */
type neuronNet = {
	volatile neuronLayer layers[];			/* array of net layers */
	volatile neuron neurons[];			/* array of all neurons */
};

/* neuron net: run-time */
type neuronNetRuntime = {
	volatile neuronLayerRuntime layers[];		/* array of net layers */
	const netTrainingFunc training;			/* training function */
	volatile any data;				/* data for training function */
};

/* neuron class data: compile-time */
type neuronDataCompile = {
	const registryData registry;			/* system registry */
	volatile neuronNet net;				/* neuron net */
	int flags;					/* flags */
	int registrySet;				/* 1 if registry set */
};

/* neuron class data: all */
type neuronData = {
	volatile neuronDataCompile cdata;
	volatile neuronNetRuntime net;			/* neuron net */
	volatile randData rand;				/* random generator data */
};

/* neuron class inplementation */
type neuronImpl = {
	volatile neuronData data;
	const neuronMethods methods;
};
