/* neuron class */
char methodVersion[] = "construct() method implementation, T19.387-T19.683"; /* $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "neuron.dpvmake"

type constructData = {
	volatile stateful any neuronObj;
	const char error[];
};

/* function to add new full layer */
(volatile stateful constructData d, const char activationName[], int nNeurons) -> () full = {
	if (d.error.csize)
		return;

	neuronImpl impl;
	char error[] = convertObjToImpl(impl, d.neuronObj, "construct:full");
	if (error.csize) {
		d.error = error;
		return;
	}

	activationFunction f;

	(f, error) = impl.methods.getActivationFunction(impl, activationName);
	if (error.csize) {
		d.error = error;
		return;
	}

	error = addFullLayer(impl, f, nNeurons);
	if (error.csize)
		d.error = error;

	return;
};

/* function to add new convolution layer */
(volatile stateful constructData d, const char activationName[], int depth, int width, int maskDepth, int maskSize,
		int step) -> () conv = {
	if (d.error.csize)
		return;

	neuronImpl impl;
	char error[] = convertObjToImpl(impl, d.neuronObj, "construct:conv");
	if (error.csize) {
		d.error = error;
		return;
	}

	activationFunction f;

	(f, error) = impl.methods.getActivationFunction(impl, activationName);
	if (error.csize) {
		d.error = error;
		return;
	}

	error = addConvolutionLayer(impl, f, depth, width, maskDepth, maskSize, step);
	if (error.csize)
		d.error = error;

	return;
};

(volatile stateful any neuronObj, const char description[]) -> (const char error[]) construct = {
	neuronImpl impl;
	char err[] = convertObjToImpl(impl, neuronObj, "construct");
	if (err.csize) return err;

	neuronDataCompile data = impl.data.cdata;

	if (!data.registrySet)
		return mkError("registry is not set", "construct");

	char program[];
	printf(program, "/* Neuron net construction function, generated by %s */

type constructData = %p;

(volatile stateful constructData data, const char activationName[], int nNeurons) -> () full = %p;
(volatile stateful constructData data, const char activationName[], int depth, int width, int maskDepth, int maskSize,
		int step) -> () conv = %p;

", {methodVersion, constructData, full, conv});

	int i;
	for (i = 0; i < activationFunctions.lsize; i += 1) {
		printf(program, "char %s[] = \"%s\";\r\n", {activationFunctions[i].name, activationFunctions[i].name});
	}

	printf(program, "
(volatile stateful constructData d) -> () constructFunction = {\r\n\t", {});

	for (i = 0; i < description.csize; i += 1) {
		char c = description[i];
		program.cpush(c);
		if (c == '(')
			program.cpush('d'), program.cpush(',');
		else if(c == ')')
			program.cpush(';');
	}

	printf(program, "\r\n\treturn;\r\n};\r\n", {});

	compsrc srcs[];
	compsrc src0;
	src0.name = "[construct]";
	src0.file = program;
	src0.links = {constructData, full, conv};
	srcs.lpush(src0);
	any func = data.registry.compiler.compile(data.registry, srcs);

	if (func.type == "".type) {
		char to[][];
		objcopyto(to, {func});
		char mess[] = to[0];
		return mess;
	}

	const type Construct = (volatile stateful constructData d) -> ();
	Construct to[], constructFunction;
	objcopyto(to, {func});
	constructFunction = to[0];

	constructData d = {impl, ""};
	constructFunction(d);

	if (d.error.csize)
		return d.error;

	return genNetTraining(impl.data);
};
