/* neuron class */
char methodVersion[] = "genGroupGradient() internal method, T19.484-T19.744"; /* $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "neuron.dpvmake"

(volatile stateful char s[], const stateful neuronLayer layer, const stateful neuronLayer prev,
		int flags, int ws, int mode) -> () printGradientParameters = {
	printf(s, "(volatile stateful float w[%d]", {ws});
	if (!mode) {
		int i;
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'a' + i, C = 'A' + i;
			printf(s, ", const stateful float %c[%d], const stateful float %c[%d]",
				{prev.groups[i].nOutputs, layer.groups[i].nOutputs, c, C});

		}
		printf(s, ", const stateful float p[%d]", {trainingParams.i[10]});
	}
	strcat(s, ")");
	return;
};

(volatile stateful char s[], int flags, int mode) -> () printGradientReturns = {
	strcat(s, "(w");
	if (!mode) {
		int i;
		for (i = 0; i < NEURON_PARALLEL; i += 1) {
			char c = 'a' + i, C = 'A' + i;
			printf(s, ",%c,%c", {c, C});
		}
		strcat(s, ",p");
	}
	strcat(s, ")");
	return;
};

(volatile stateful char s[], const stateful neuronNet net, const stateful neuronLayer layer, int wid)
		-> () printWeightSum = {
	int i, was;
	for (i = 0; i < layer.outputNeuronIds[wid].isize; i += 1) {
		if (was) s.cpush('+');
		was = 1;
		neuron n = net.neurons[layer.outputNeuronIds[wid][i]];
		char c = 'A' + n.groupId;
		printf(s, "%c[%d]", {n.outputStartId, c});
		if (layer.inputNeuronIds[wid][i] >= 0) {
			n = net.neurons[layer.inputNeuronIds[wid][i]];
			c = 'a' + n.groupId;
			printf(s, "*%c[%d]", {n.outputStartId, c});
		}
	}
	return;
};

(const stateful neuronDataCompile data, int layerId, int groupId, int startWeight) -> (const any func, int nextWeight) genPartGradient = {
	neuronNet net = data.net;
	neuronLayer layer = net.layers[layerId], prev = net.layers[layerId - 1], last = net.layers[net.layers.lsize - 1];
	neuronGroup group = layer.groups[groupId];
	int ws = group.nWeights, flags = data.flags, coeff = 1;

	if (flags & NEURON_METHOD_RMSP)
		coeff = 3;
	else if (flags & NEURON_METHOD_MOMENTUM)
		coeff = 2;

	/* generate source code for gradient function */

	char s[], name[];
	printf(name, "layer[%d].group[%d].gradient%d", {layerId, groupId, startWeight});
	printf(s, "/* Source of %s, generated by %s */\r\n", {name, methodVersion});
	printGradientParameters(s, layer, prev, flags, ws * coeff, 0);
	strcat(s, " ->\r\n");
	printGradientParameters(s, layer, prev, flags, ws * coeff, 0);
	printf(s, " gradient%d = {\r\n\tfloat s;\r\n", {startWeight});

	int i;
	for (i = startWeight; i < ws && s.csize < SOURCE_MAX; i += 1) {
		int wid = i + group.weightStartId - layer.weightStartId;
		if (flags & NEURON_METHOD_ADAM)
			strcat(s, "\ts = "), printWeightSum(s, net, layer, wid), strcat(s, ";\r\n");
		if (flags & NEURON_METHOD_MOMENTUM)
			printf(s, "\tw[%d] = p[1]*w[%d] + (1.0-p[1])*s;\r\n", {i + ws, i + ws});
		if (flags & NEURON_METHOD_RMSP)
			printf(s, "\tw[%d] = p[2]*w[%d] + (1.0-p[2])*s*s;\r\n", {i + 2 * ws, i + 2 * ws});
		printf(s, "\tw[%d] -= p[0]*", {i});
		if (flags & NEURON_METHOD_ADAM) {
			if (flags & NEURON_METHOD_MOMENTUM)
				printf(s, "w[%d]", {i + ws});
			else
				strcat(s, "s");
			if (flags & NEURON_METHOD_RMSP)
				printf(s, "/(fsqrt(w[%d])+p[3])", {i + 2 * ws});
		} else
			strcat(s, "("), printWeightSum(s, net, layer, wid), strcat(s, ")");
		strcat(s, ";\r\n");
	}
	strcat(s, "\treturn ");
	printGradientReturns(s, flags, 0);
	strcat(s, ";\r\n};\r\n");

	if (i >= ws)
		i = -1;


	/* compile gradient function */

	return (compile(data, name, s, {}), i);
};

(const stateful neuronDataCompile data, int layerId, int groupId) -> (const any func, int nSubroutines) genGroupGradient = {
	neuronNet net = data.net;
	neuronLayer layer = net.layers[layerId], prev = net.layers[layerId - 1];
	neuronGroup group = layer.groups[groupId];
	int ws = group.nWeights, flags = data.flags, coeff = 1;

	if (flags & NEURON_METHOD_RMSP)
		coeff = 3;
	else if (flags & NEURON_METHOD_MOMENTUM)
		coeff = 2;

	char s[], name[];
	printf(name, "layer[%d].group[%d].gradient", {layerId, groupId});
	printf(s, "/* Source of %s, generated by %s */\r\n", {name, methodVersion});
	printGradientParameters(s, layer, prev, flags, ws * coeff, 0);
	strcat(s, " ->\r\n");
	printGradientParameters(s, layer, prev, flags, ws * coeff, 1);
	printf(s, " gradient = {\r\n", {});

	any links;
	int j, nSubroutines;
	do {
		any func;
		(func, j) = genPartGradient(data, layerId, groupId, j);
		if (func.type == "".type)
			return (func, nSubroutines);

		printf(s, "\t%p", {func});
		printGradientReturns(s, flags, 0);
		printf(s, ";\r\n", {});
		links.lpush(func);
		nSubroutines += 1;
	} while (j != -1);

	strcat(s, "\treturn ");
	printGradientReturns(s, flags, 1);
	strcat(s, ";\r\n};\r\n");

	return (compile(data, name, s, links), nSubroutines);
};
