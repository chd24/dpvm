/* mul two long numbers and return result; T17.523-T17.993; $DVS:time$ */

#include "long.dpvmake"

int simple_threshold = 4;
int karatsuba_threshold = 32;

int Z = 0x8000000000000000;

(volatile stateful int m[], int size, int s1, int s2) -> (int res) cmp_mem {
	while (size) {
		size -= 1;
		int a1 = m[s1 + size] + Z;
		int a2 = m[s2 + size] + Z;
		if (a1 > a2) return 1;
		if (a1 < a2) return -1;
	}
	return 0;
}

(volatile stateful int m[], int size, int s1, int s2, int d) -> (int p) add_mem {
	int p = Z;
	int i;
	for (i = 0; i < size; i += 1) {
		int a1 = m[s1 + i] + p;
		int a2 = m[s2 + i] + a1;
		m[d + i] = a2 + Z;
		p = ((p > a1) | (a1 > a2)) + Z;
	}
	return p + Z;
}

(volatile stateful int m[], int size, int s1, int s2, int d) -> (int p) sub_mem {
	int p;
	int i;
	for (i = 0; i < size; i += 1) {
		int a1 = m[s1 + i] + Z;
		int q = a1 - m[s2 + i];
		int r = q - p;
		m[d + i] = r + Z;
		p = (q > a1) | (r > q);
	}
	return p;
}

(volatile stateful int m[], int size, int s1, int s2, int d) -> () pythagoras_mul_mem {
	int i;
	int j;

	for (i = 0; i < size; i += 1)
		m[d + i] = 0;

	for (j = 0; j < size; j += 1) {
		int n = m[s2 + j];
		int p;

		for (i = 0; i < size; i += 1) {
			int l = m[s1 + i];
			int h = n;
			asm { mul };
			p += Z;
			l += p;
			int q = m[d + i + j] + l;
			m[d + i + j] = q + Z;
			p = h + (l < p) + (q < l);
		}
		
		m[d + i + j] = p;
	}

	return;
}

(volatile stateful int m[], int size, int x, int y, int z, int t) -> () karatsuba_mul_mem {
	if (size <= karatsuba_threshold) {
            if (size == 32)
                (
                m[z+63],m[z+62],m[z+61],m[z+60],m[z+59],m[z+58],m[z+57],m[z+56],
                m[z+55],m[z+54],m[z+53],m[z+52],m[z+51],m[z+50],m[z+49],m[z+48],
                m[z+47],m[z+46],m[z+45],m[z+44],m[z+43],m[z+42],m[z+41],m[z+40],
                m[z+39],m[z+38],m[z+37],m[z+36],m[z+35],m[z+34],m[z+33],m[z+32],
                m[z+31],m[z+30],m[z+29],m[z+28],m[z+27],m[z+26],m[z+25],m[z+24],
                m[z+23],m[z+22],m[z+21],m[z+20],m[z+19],m[z+18],m[z+17],m[z+16],
                m[z+15],m[z+14],m[z+13],m[z+12],m[z+11],m[z+10],m[z+ 9],m[z+ 8],
                m[z+ 7],m[z+ 6],m[z+ 5],m[z+ 4],m[z+ 3],m[z+ 2],m[z+ 1],m[z+ 0]
                ) = mul_long_32(
                m[x+31],m[x+30],m[x+29],m[x+28],m[x+27],m[x+26],m[x+25],m[x+24],
                m[x+23],m[x+22],m[x+21],m[x+20],m[x+19],m[x+18],m[x+17],m[x+16],
                m[x+15],m[x+14],m[x+13],m[x+12],m[x+11],m[x+10],m[x+ 9],m[x+ 8],
                m[x+ 7],m[x+ 6],m[x+ 5],m[x+ 4],m[x+ 3],m[x+ 2],m[x+ 1],m[x+ 0],
                m[y+31],m[y+30],m[y+29],m[y+28],m[y+27],m[y+26],m[y+25],m[y+24],
                m[y+23],m[y+22],m[y+21],m[y+20],m[y+19],m[y+18],m[y+17],m[y+16],
                m[y+15],m[y+14],m[y+13],m[y+12],m[y+11],m[y+10],m[y+ 9],m[y+ 8],
                m[y+ 7],m[y+ 6],m[y+ 5],m[y+ 4],m[y+ 3],m[y+ 2],m[y+ 1],m[y+ 0]
                );
            else if (size == 16)
                (
                m[z+31],m[z+30],m[z+29],m[z+28],m[z+27],m[z+26],m[z+25],m[z+24],
                m[z+23],m[z+22],m[z+21],m[z+20],m[z+19],m[z+18],m[z+17],m[z+16],
                m[z+15],m[z+14],m[z+13],m[z+12],m[z+11],m[z+10],m[z+ 9],m[z+ 8],
                m[z+ 7],m[z+ 6],m[z+ 5],m[z+ 4],m[z+ 3],m[z+ 2],m[z+ 1],m[z+ 0]
                ) = mul_long_16(
                m[x+15],m[x+14],m[x+13],m[x+12],m[x+11],m[x+10],m[x+ 9],m[x+ 8],
                m[x+ 7],m[x+ 6],m[x+ 5],m[x+ 4],m[x+ 3],m[x+ 2],m[x+ 1],m[x+ 0],
                m[y+15],m[y+14],m[y+13],m[y+12],m[y+11],m[y+10],m[y+ 9],m[y+ 8],
                m[y+ 7],m[y+ 6],m[y+ 5],m[y+ 4],m[y+ 3],m[y+ 2],m[y+ 1],m[y+ 0]
                );
            else if (size == 8)
                (
                m[z+15],m[z+14],m[z+13],m[z+12],m[z+11],m[z+10],m[z+ 9],m[z+ 8],
                m[z+ 7],m[z+ 6],m[z+ 5],m[z+ 4],m[z+ 3],m[z+ 2],m[z+ 1],m[z+ 0]
                ) = mul_long_8(
                m[x+ 7],m[x+ 6],m[x+ 5],m[x+ 4],m[x+ 3],m[x+ 2],m[x+ 1],m[x+ 0],
                m[y+ 7],m[y+ 6],m[y+ 5],m[y+ 4],m[y+ 3],m[y+ 2],m[y+ 1],m[y+ 0]
                );
            else if (size == 4)
                (
                m[z+ 7],m[z+ 6],m[z+ 5],m[z+ 4],m[z+ 3],m[z+ 2],m[z+ 1],m[z+ 0]
                ) = mul_long_4(
                m[x+ 3],m[x+ 2],m[x+ 1],m[x+ 0],m[y+ 3],m[y+ 2],m[y+ 1],m[y+ 0]
                );
            else
                pythagoras_mul_mem(m, size, x, y, z);
            return;
	}

	int hsize = size >> 1;

	int A = x + hsize;
	int B = x;
	int C = y + hsize;
	int D = y;

	int r = 1;
	int AmB = z;
	if (cmp_mem(m, hsize, A, B) >= 0) sub_mem(m, hsize, A, B, AmB);
	else sub_mem(m, hsize, B, A, AmB), r = -r;

	int CmD = z + hsize;
	if (cmp_mem(m, hsize, C, D) >= 0) sub_mem(m, hsize, C, D, CmD);
	else sub_mem(m, hsize, D, C, CmD), r = -r;

	int AmBxCmD = t;
	int ht = t + size;
	code(m, hsize, AmB, CmD, AmBxCmD, ht);

	int AC = z + size;
	int BD = z;

	code(m, hsize, A, C, AC, ht);
	code(m, hsize, B, D, BD, ht);

	int ADpBC = ht;
	int p = add_mem(m, size, AC, BD, ADpBC);
	if (r > 0)
		p -= sub_mem(m, size, ADpBC, AmBxCmD, ADpBC);
	else
		p += add_mem(m, size, ADpBC, AmBxCmD, ADpBC);

	p += add_mem(m, size, BD + hsize, ADpBC, BD + hsize);

	int i;
	for (i = AC + hsize; p; i += 1) {
		p += Z;
		int n = m[i] + p;
		m[i] = n + Z;
		p = (n < p);
	}	

	return;
}

(const stateful int s1[], const stateful int s2[]) -> (volatile int res[]) {
	int s1size = s1.isize;
	int s2size = s2.isize;

	if (!s1size || !s2size) {
		int res[];
		return res;
	}

        if (s1size < simple_threshold || s2size < simple_threshold || s1size > s2size * s2size || s2size > s1size * s1size)
            return mul_pythagoras(s1, s2);

        int size = simple_threshold;
        while (s1size > size || s2size > size)
            size <<= 1;

	int res[];
	int i;
	int base = 6 * size;
	for (i = 0; i < base; i += 1)
		res.ipush(0);

	base = 2 * size;
	for (i = 0; i < s1size; i += 1)
		res[base + i] = s1[i];

	base = 3 * size;
	for (i = 0; i < s2size; i += 1)
		res[base + i] = s2[i];

	karatsuba_mul_mem(res, size, 2 * size, 3 * size, 0, 4 * size);

	res.ipop(4 * size);
	while (res.isize && !res[res.isize - 1]) res.ipop(1);

	return res;
}
