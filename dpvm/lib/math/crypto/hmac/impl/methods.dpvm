/* hmac class, methods implementation, T19.991-T20.069; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.1, T19.354-T19.744 */

#include "../../../../stdlib/stdlib.dpvmake"
#include "../../../../../tools/registry/registry.dpvmake"
#include "hash/hash.dpvmake"
#include "hmac.dpvmake"
#include "version.dpvmh"

int registryMask = REGISTRY_COMPILER;	/* mask of registry applications used by hmac class */

(volatile stateful any hmacObj) -> (const char error[], int flags) getFlags = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any hmacObj, int flags) -> (const char error[]) setFlags = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any hmacObj, const stateful any registry) -> (const char error[]) setRegistry = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(volatile stateful any hmacObj, const char hashName[]) -> (const char error[]) setHash = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "setHash");
	if (err.csize) return err;

	int i, size = hmacHashes.lsize;

	for (i = 0; i < size; i += 1) {
		if (hmacHashes[i].name == hashName) {
			impl.data.hash = hmacHashes[i];
			impl.data.hashSet = 1;
			impl.data.keySet = 0;
			return "";
		}
	}

	return mkError("hash algorithm not found", "setHash");
};

(volatile stateful any hmacObj, const char key[]) -> (const char error[]) setKey = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "setKey");
	if (err.csize) return err;

	if (!impl.data.hashSet)
		return mkError("hash is not set", "setKey");

	int blockSize = impl.data.hash.blockSize;

	if (key.csize > blockSize) {
		char res[];
		impl.data.hash.strToStrHash(res, key);
		key = res;
	}

	if (key.csize < blockSize) {
		char res[];
		strcat(res, key);
		while (res.csize < blockSize)
			res.cpush(0);
		key = res;
	}

	char iKeyPad[], oKeyPad[];
	int i;
	for (i = 0; i < blockSize; i += 1) {
		iKeyPad.cpush(key[i] ^ 0x36);
		oKeyPad.cpush(key[i] ^ 0x5c);
	}

	any iKeyContext = impl.data.hash.init();
	impl.data.hash.addStr(iKeyContext, iKeyPad);
	impl.data.iKeyContext = iKeyContext;

	any oKeyContext = impl.data.hash.init();
	impl.data.hash.addStr(oKeyContext, oKeyPad);
	impl.data.oKeyContext = oKeyContext;

	impl.data.keySet = 1;

	return "";
};

(volatile stateful char output[], const stateful any hmacObj, const char message[]) -> (const char error[]) computeHash = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "computeHash");
	if (err.csize) return err;

	if (!impl.data.hashSet)
		return mkError("hash is not set", "computeHash");

	impl.data.hash.strToStrHash(output, message);

	return "";
};

(volatile stateful char output[], const stateful any hmacObj, const char message[]) -> (const char error[]) signMessage = {
	hmacImpl impl;
	char err[] = convertObjToImpl(impl, hmacObj, "signMessage");
	if (err.csize) return err;

	if (!impl.data.keySet)
		return mkError("key is not set", "signMessage");

	char tmp[];

	any iCtx = impl.data.hash.copyCtx(impl.data.iKeyContext);
	impl.data.hash.addStr(iCtx, message);
	impl.data.hash.finish(tmp, iCtx);

	any oCtx = impl.data.hash.copyCtx(impl.data.oKeyContext);
	impl.data.hash.addStr(oCtx, tmp);
	impl.data.hash.finish(output, oCtx);

	return "";
};

(const (volatile stateful any data, const char hashName[], const hmacTest test) -> (const char error[]) callback,
		volatile stateful any data) -> (const char error[]) forAllTests = {
	int i, size = hmacHashes.lsize;

	for (i = 0; i < size; i += 1) {
		hmacHash h = hmacHashes[i];
		int j, tsize = h.tests.lsize;
		for (j = 0; j < tsize; j += 1) {
			char error[] = callback(data, h.name, h.tests[j]);
			if (error.csize)
				return error;
		}
	}

	return "";
};

hmacMethods hmacMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setRegistry,
	setHash,
	setKey,
	computeHash,
	signMessage,
	forAllTests,
	dump
};
