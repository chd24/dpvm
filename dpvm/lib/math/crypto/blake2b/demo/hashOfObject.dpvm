/* blake2b class, hashOfObject demo, T20.353-T20.353; $DVS:time$ */

#include "../../../../utils/utils.dpvmake"
#include "../blake2b.dpvmake"

int INT_MIN	= 0x8000000000000000;
int INT_MAX	= 0x7fffffffffffffff;

(volatile stateful char db[], int n) -> () pushInt = {
	int i;
	for (i = 0; i < 8; i++)
		db.cpush(n), n >>= 8;
	return;
};

(volatile stateful char db[], const any parent, const any obj) -> () pushObjectHash = {
	int a, b, c, d;
	if (parent != obj)
		(a, b, c, d) = getfullhash(obj);
	pushInt(db, a);
	pushInt(db, b);
	pushInt(db, c);
	pushInt(db, d);
	return;
};

(volatile stateful char db[], float f) -> () pushFloat {
	int mantissa, exponent, ieee;
	(mantissa, exponent) = fsplit(f);

	if (mantissa < 0) {
		mantissa = -mantissa;
		ieee = INT_MIN;
	}

	if (exponent > INT_MIN && exponent < INT_MAX)
		exponent += 1023 + 52;

	pushInt(db, ieee | mantissa & 0xfffffffffffff | (exponent & 0x7ff) << 52);
	return;
}


(const any obj) -> (int a, int b, int c, int d) hashOfObject = {
	blake2bClass blake2bObj = blake2bCreate();

	char db[], out1[], out2[];

	int a, b, c, d, e, f, g, h;
	type t;
	(t, a, b, c, d, e, f, g, h) = object_info(obj);
	pushInt(db, a); pushInt(db, b); pushInt(db, c); pushInt(db, d);
	pushInt(db, e); pushInt(db, f); pushInt(db, g); pushInt(db, h);
	pushObjectHash(db, obj, t);

	int i;
	for (i = 0; i < obj.lsize; i++)
		pushObjectHash(db, obj, obj.l[i]);

	for (i = 0; i < obj.isize; i++)
		pushInt(db, obj.i[i]);

	for (i = 0; i < obj.fsize; i++)
		pushFloat(db, obj.f[i]);

	for (i = 0; i < obj.csize; i++)
		db.cpush(obj.c[i]);

	blake2bObj.methods.addString(blake2bObj, db);
	blake2bObj.methods.finish(out1, blake2bObj);

	blake2bObj.methods.setOutputLength(blake2bObj, 32);
	blake2bObj.methods.addString(blake2bObj, out1);
	blake2bObj.methods.finish(out2, blake2bObj);

	int res[] = chars2ints(out2, 0, 32);
	return (res[0], res[1], res[2], res[3]);
};
