/* json class, methods implementation, T19.555-T20.035; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.0, T19.354-T19.358 */

#include "../../../../stdlib/stdlib.dpvmake"
#include "json.dpvmake"
#include "version.dpvmh"

(volatile stateful any jsonObj) -> (const char error[], int flags) getFlags = {
	jsonImpl impl;
	char err[] = convertObjToImpl(impl, jsonObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any jsonObj, int flags) -> (const char error[]) setFlags = {
	jsonImpl impl;
	char err[] = convertObjToImpl(impl, jsonObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(const stateful char name[], int jsonType) -> (volatile jsonObject obj) makeObject = {
	jsonObject obj;

	if (jsonType & ~(JSON_NAME | JSON_TYPES))
		jsonType = JSON_NULL | jsonType & JSON_NAME;

	obj.c[0] = jsonType;

	if (jsonType & JSON_NAME) {
		int i, size = name.csize;
		for (i = 0; i < size; i += 1)
			obj.cpush(name[i]);
		jsonType &= ~JSON_NAME;
	}

	if (jsonType == JSON_INT)
		obj.ipush(0);
	else if (jsonType == JSON_FLOAT)
		obj.fpush(0.0);
	else if (jsonType == JSON_STRING)
		obj.cpush(0);

	return obj;
};

(const stateful jsonObject obj) -> (int value) isNull = {
	return obj.c[0] == JSON_NULL;
};

(const stateful jsonObject obj) -> (const char error[], int value) getBool = {
	if ((obj.c[0] & JSON_TYPES) != JSON_FALSE && (obj.c[0] & JSON_TYPES) != JSON_TRUE)
		return (mkError("object is not boolean", "getBool"), 0);
	return ("", obj.c[0] == JSON_TRUE);
};

(const stateful jsonObject obj) -> (const char error[], int number) getInt = {
	if ((obj.c[0] & JSON_TYPES) != JSON_INT)
		return (mkError("object is not integer", "getInt"), 0);
	if (!obj.isize)
		return (mkError("illegal integer object", "getInt"), 0);
	return ("", obj.i[0]);
};

(const stateful jsonObject obj) -> (const char error[], float number) getFloat = {
	if ((obj.c[0] & JSON_TYPES) != JSON_FLOAT)
		return (mkError("object is not float", "getFloat"), 0);
	if (!obj.fsize)
		return (mkError("illegal float object", "getFloat"), 0);
	return ("", obj.f[0]);
};

(volatile stateful char out[], const stateful jsonObject obj) -> (const char error[]) getName = {
	if (!(obj.c[0] & JSON_NAME))
		return mkError("object has no name", "getName");
	int pos = 1, size = obj.csize;
	for (pos = pos; pos < size; pos += 1)
		out.cpush(obj.c[pos]);

	return "";
};

(volatile stateful char out[], const stateful jsonObject obj) -> (const char error[]) getString = {
	if ((obj.c[0] & JSON_TYPES) != JSON_STRING)
		return mkError("object is not a string", "getString");
	int pos = 1, size = obj.csize;
	if (obj.c[0] & JSON_NAME) {
		for (pos = pos; pos < size && obj.c[pos]; pos += 1);
		if (pos >= size)
			return mkError("illegal string object", "getString");
		pos += 1;
	}
	for (pos = pos; pos < size; pos += 1)
		out.cpush(obj.c[pos]);

	return "";
};

(volatile stateful jsonObject obj, const stateful char name[]) -> (volatile stateful jsonObject obj) getObjectByName = {
	int i, size = obj.lsize, len = name.csize;
	for (i = 0; i < size; i += 1) {
		jsonObject subobj = obj.l[i];
		if (subobj.c[0] & JSON_NAME) {
			int j, sublen = subobj.csize - 1;
			for (j = 0; j < len && j < sublen && subobj.c[j + 1] && subobj.c[j + 1] == name[j]; j += 1);
			if (j == len && (j == sublen || !subobj.c[j + 1]))
				return subobj;
		}
	}
	return makeObject("", JSON_NULL);
};

(volatile stateful jsonObject obj, int index) -> (volatile stateful jsonObject obj) getObjectByIndex = {
	if (index >= 0 && index < obj.lsize)
		return obj.l[index];
	return makeObject("", JSON_NULL);
};

(volatile stateful jsonObject obj, int number) -> (const char error[]) setInt = {
	if ((obj.c[0] & JSON_TYPES) != JSON_INT)
		return mkError("object is not integer", "setInt");
	if (!obj.isize)
		return mkError("illegal integer object", "setInt");
	obj.i[0] = number;
	return "";
};

(volatile stateful jsonObject obj, float number) -> (const char error[]) setFloat = {
	if ((obj.c[0] & JSON_TYPES) != JSON_FLOAT)
		return mkError("object is not float", "setFloat");
	if (!obj.fsize)
		return mkError("illegal float object", "setFloat");
	obj.f[0] = number;
	return "";
};

(volatile stateful jsonObject obj, const stateful char str[]) -> (const char error[]) setString = {
	if ((obj.c[0] & JSON_TYPES) != JSON_STRING)
		return mkError("object is not a string", "setString");
	int pos = 1, size = obj.csize;
	if (obj.c[0] & JSON_NAME) {
		for (pos = pos; pos < size && obj.c[pos]; pos += 1);
		if (pos >= size)
			return mkError("illegal string object", "setString");
		pos += 1;
	}
	obj.cpop(size - pos);
	size = str.csize;
	for (pos = 0; pos < size; pos += 1)
		obj.cpush(str[pos]);

	return "";
};

(volatile stateful jsonObject obj, volatile stateful jsonObject subObj) -> (const char error[]) addObject = {
	if ((obj.c[0] & JSON_TYPES) != JSON_ARRAY && (obj.c[0] & JSON_TYPES) != JSON_OBJECT)
		return mkError("object is not composite (array or object)", "addObject");
	obj.lpush(subObj);
	return "";
};

(volatile stateful char out[], const stateful jsonObject obj) -> (const char error[]) serialize = {
	int objType = obj.c[0], pos = 1;

	if (objType & JSON_NAME) {
		out.cpush('"');
		int size = obj.csize;
		for (pos = pos; pos < size && obj.c[pos]; pos += 1)
			out.cpush(obj.c[pos]);
		if (pos < size)
			pos += 1;
		out.cpush('"');
		out.cpush(':');
		objType &= ~JSON_NAME;
	}

	if (objType == JSON_NULL)
		strcat(out, "null");

	else if (objType == JSON_FALSE)
		strcat(out, "false");

	else if (objType == JSON_TRUE)
		strcat(out, "true");

	else if (objType == JSON_INT) {
		if (!obj.isize)
			return mkError("illegal integer json object", "serialize");
		printf(out, "%d", {obj.i[0]});

	} else if (objType == JSON_FLOAT) {
		if (!obj.fsize)
			return mkError("illegal float json object", "serialize");
		printf(out, "%f", {obj.f[0]});

	} else if (objType == JSON_STRING) {
		int size = obj.csize;
		out.cpush('"');
		for (pos = pos; pos < size; pos += 1)
			out.cpush(obj.c[pos]);
		out.cpush('"');

	} else if (objType == JSON_ARRAY) {
		int i, size = obj.lsize;
		out.cpush('[');
		for (i = 0; i < size; i += 1) {
			if (i) out.cpush(',');
			char error[] = code(out, obj.l[i]);
			if (error.csize)
				return error;
		}
		out.cpush(']');

	} else if (objType == JSON_OBJECT) {
		int i, size = obj.lsize;
		out.cpush('{');
		for (i = 0; i < size; i += 1) {
			if (i) out.cpush(',');
			char error[] = code(out, obj.l[i]);
			if (error.csize)
				return error;
		}
		out.cpush('}');

	} else {
		return mkError("illegal type of json object", "serialize");
	}

	return "";
};

(const stateful char str[], int begin, int end) -> (int nextbegin) skipSpaces = {
	while (begin < end) {
		int c = str[begin];
		if (c != ' ' && c != '\t' && c != '\r' && c != '\n' && c != ',')
			return begin;
		begin += 1;
	}
	return begin;
};

(volatile stateful char out[], const stateful char str[], int begin, int end) -> (int nextbegin) readString = {
	if (begin >= end || str[begin] != '"')
		return -1;
	begin += 1;
	while (begin < end) {
		int c = str[begin];
		begin += 1;
		if (c == '"')
			return begin;
		if (c == '\\') {
			if (begin >= end)
				return -1;
			c = str[begin];
			begin += 1;
			if (c == 'n')
				c = '\n';
			else if (c == 't')
				c = '\t';
			else if (c == 'r')
				c = '\r';
		}
		out.cpush(c);
	}
	return -1;
};

(const stateful char str[], int begin, int end) -> (volatile jsonObject obj, const char error[], int nextBegin) deserialize = {
	char name[];
	begin = skipSpaces(str, begin, end);
	if (begin >= end)
		return (makeObject("", JSON_NULL), mkError("unterminated object", "deserialize"), begin);
	int c = str[begin], objType;

	if (c == '"') {
		begin = readString(name, str, begin, end);
		if (begin < 0)
			return (makeObject("", JSON_NULL), mkError("unterminated string", "deserialize"), begin);
		begin = skipSpaces(str, begin, end);
		if (begin >= end || str[begin] != ':') {
			jsonObject obj = makeObject("", JSON_STRING);
			return (obj, setString(obj, name), begin);
		}
		begin += 1;
		if (begin >= end)
			return (makeObject("", JSON_NULL), mkError("unterminated named object", "deserialize"), begin);
		objType = JSON_NAME;
		c = str[begin];
	}

	if (c == '{' || c == '[') {
		char error[];
		jsonObject subobj;

		begin += 1;
		if (c == '{') c = '}', objType |= JSON_OBJECT;
		else c = ']', objType |= JSON_ARRAY;
		jsonObject obj = makeObject(name, objType);

		while (1) {
			begin = skipSpaces(str, begin, end);
			if (begin >= end)
				return (makeObject("", JSON_NULL),
						mkError("unterminated composite object", "deserialize"), begin);
			if (str[begin] == c)
				return (obj, "", begin + 1);

			(subobj, error, begin) = code(str, begin, end);
			if (error.csize)
				return (makeObject("", JSON_NULL), error, begin);

			error = addObject(obj, subobj);
			if (error.csize)
				return (makeObject("", JSON_NULL), error, begin);
		}

	} else if (c == '"') {
		jsonObject obj = makeObject(name, objType | JSON_STRING);
		name.cpop(name.csize);
		begin = readString(name, str, begin, end);
		if (begin < 0)
			return (makeObject("", JSON_NULL), mkError("unterminated string", "deserialize"), begin);
		return (obj, setString(obj, name), begin);

	} else if (c >= 'a' && c <= 'z') {
		char keyword[];
		do {
			keyword.cpush(c);
			begin += 1;
			if (begin < end)
				c = str[begin];
		} while (begin < end && c >= 'a' && c <= 'z');

		if (keyword == "null")
			return (makeObject(name, objType | JSON_NULL), "", begin);
		if (keyword == "false")
			return (makeObject(name, objType | JSON_FALSE), "", begin);
		if (keyword == "true")
			return (makeObject(name, objType | JSON_TRUE), "", begin);

		return (makeObject("", JSON_NULL), mkError("unknown json keyword", "deserialize"), begin);
	} else {
		int err, num, nextbegin;
		float fnum;
		(err, nextbegin, fnum) = strtof(str, begin, end);
		if (!err) {
			jsonObject obj = makeObject(name, objType | JSON_FLOAT);
				return (obj, setFloat(obj, fnum), nextbegin);
		}

		(num, err, nextbegin) = strtoi(str, begin, end, 0);
		if (!err) {
			jsonObject obj = makeObject(name, objType | JSON_INT);
			return (obj, setInt(obj, num), nextbegin);
		}
	}

	return (makeObject("", JSON_NULL), mkError("malformad json object", "deserialize"), begin);
};

jsonMethods jsonMethodsImpl = {
	version,
	getFlags,
	setFlags,
	dump,
	makeObject,
	isNull,
	getBool,
	getInt,
	getFloat,
	getName,
	getString,
	getObjectByName,
	getObjectByIndex,
	setInt,
	setFloat,
	setString,
	addObject,
	serialize,
	deserialize
};
