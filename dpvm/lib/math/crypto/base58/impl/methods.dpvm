/* base58 class, methods implementation, T19.570-T20.165; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.0, T19.354-T19.358 */

#include "../../../long/long.dpvmake"
#include "base58.dpvmake"
#include "version.dpvmh"

(volatile stateful any base58Obj) -> (const char error[], int flags) getFlags = {
	base58Impl impl;
	char err[] = convertObjToImpl(impl, base58Obj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any base58Obj, int flags) -> (const char error[]) setFlags = {
	base58Impl impl;
	char err[] = convertObjToImpl(impl, base58Obj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful char out[], const stateful char str[], int begin, int end) -> () encode = {
	while (begin < end && !str[begin]) {
		out.cpush('1');
		begin += 1;
	}

	if (begin >= end)
		return;

	int longNum[], i, n, shift;

	for (i = end - 1; i >= begin; i -= 1) {
		n |= str[i] << shift;
		shift += 8;
		if (shift == 64 || i == begin) {
			longNum.ipush(n);
			n = 0;
			shift = 0;
		}
	}

	char reverse[];

	while (longNum.isize) {
		reverse.cpush(base58Alphabet[mod_short(longNum, 58)]);
		div_small(longNum, 58);
	}

	for (i = reverse.csize - 1; i >= 0; i -= 1)
		out.cpush(reverse[i]);

	return;
};

(volatile stateful char out[], const stateful any base58Obj, const stateful char str[], int begin, int end)
		-> (const char error[]) decode = {
	while (begin < end && str[begin] == '1') {
		out.cpush(0);
		begin += 1;
	}

	if (begin >= end)
		return "";

	base58Impl impl;
	char err[] = convertObjToImpl(impl, base58Obj, "decode");
	if (err.csize) return err;

	int longNum[], i;
	for (i = begin; i < end; i += 1) {
		int n = impl.data.decodeMap[str[i]];
		if (n >= 58)
			return mkError("illegal symbol in base58 code", "decode");
		mul_short(longNum, 58);
		add_short(longNum, n);
	}

	int size = longNum.isize - 1, n = longNum[size], shift;
	for (shift = 8; shift < 64 && n >> shift; shift += 8);
	for (shift -= 8; shift >= 0; shift -= 8)
		out.cpush(n >> shift);

	for (i = size - 1; i >= 0; i -= 1) {
		n = longNum[i];
		for (shift = 56; shift >= 0; shift -= 8)
			out.cpush(n >> shift);
	}

	return "";
};

(volatile stateful char out[], int hash) -> () encodeInt = {
	int i, size = out.csize;
	out.cpush(base58Alphabet[9]);
	for (i = 0; i < 10; i++)
		out.cpush(base58Alphabet[0]);

	for (i = 10; i >= 0 && hash; i--) {
		int c = hash & 1;
		hash >>= 1;
		c |= hash % 29 << 1;
		hash /= 29;
		out[size + i] = base58Alphabet[i ? c : c + 9];
	}

	return;
};

(const stateful char decodeMap[256], const stateful char str[], int begin, int end) -> (int hash, int error) decodeInt = {
	if (end > str.csize || begin < 0)
		return (0, -1);

	if (end - begin != 11)
		return (0, -2);

	int i, hash;
	for (i = begin; i < end; i++) {
		int n = decodeMap[str[i]];
		if (n >= 58)
			return (0, -3);
		if (i == begin) {
			if (n < 9)
				return (0, -4);
			n -= 9;
		}
		hash *= 58;
		hash += n;
	}

	return (hash, 0);
};

(volatile stateful char out[], int hash0, int hash1, int hash2, int hash3) -> () encodeHash = {
	encodeInt(out, hash0); out.cpush('_');
	encodeInt(out, hash1); out.cpush('_');
	encodeInt(out, hash2); out.cpush('_');
	encodeInt(out, hash3);
	return;
};

(volatile stateful int hashes[], const stateful any base58Obj, const stateful char str[], int begin, int end) -> (int error) decodeHash = {
	if (end > str.csize || begin < 0)
		return -1;

	if (end - begin != 47 || str[begin + 11] != '_' || str[begin + 23] != '_' || str[begin + 35] != '_')
		return -2;

	base58Impl impl;
	char err[] = convertObjToImpl(impl, base58Obj, "decodeHash");
	if (err.csize) return -3;

	int hash0, hash1, hash2, hash3, error;
	(hash0, error) = decodeInt(impl.data.decodeMap, str, begin,      begin + 11); if (error) return error * 4;
	(hash1, error) = decodeInt(impl.data.decodeMap, str, begin + 12, begin + 23); if (error) return error * 4 - 1;
	(hash2, error) = decodeInt(impl.data.decodeMap, str, begin + 24, begin + 35); if (error) return error * 4 - 2;
	(hash3, error) = decodeInt(impl.data.decodeMap, str, begin + 36, begin + 47); if (error) return error * 4 - 3;
	hashes.ipush(hash0);
	hashes.ipush(hash1);
	hashes.ipush(hash2);
	hashes.ipush(hash3);
	return 0;
};

base58Methods base58MethodsImpl = {
	version,
	getFlags,
	setFlags,
	dump,
	encode,
	decode,
	encodeHash,
	decodeHash
};
