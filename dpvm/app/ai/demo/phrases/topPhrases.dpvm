/* aiPhrases class, topPhrases demo, T18.421-T18.441; $DVS:time$ */

#include "../../../stdlib/stdlib.dpvmake"
#include "../../alphabet.dpvmake"
#include "demo.dpvmake"

type parserData = {
	volatile char input[];
	const char inputFile[];
	const char codeTable[];
	int nPhrases;
};

(volatile parserData data, const char text[]) -> (const char out[], int status) processText = {
	char err[];

	aiAlphabet aiA = aiAlphabetCreate();

	char indexes[];
	(indexes, err) = aiA.methods.parseText(aiA, data.codeTable, data.input);
	if (err.csize) return (err, 1);

	int stats[];
	(stats, err) = aiA.methods.getStatistics(aiA, data.codeTable);
	if (err.csize) return (err, 2);

	char defCodeTable[];
	(defCodeTable, err) = aiA.methods.getDefaultCodeTable(aiA, data.codeTable);
	if (err.csize) return (err, 3);

	char letters[][];
	(letters, err) = aiA.methods.getLetters(aiA, defCodeTable, AI_ALPHABET_SMALL);
	if (err.csize) return (err, 4);

	aiVocabulary aiV = vocabularyCreate();

	err = aiV.methods.setStatistics(aiV, stats);
	if (err.csize) return (err, 5);

	char words[];
	int pos;
	(err, pos) = aiV.methods.parseIndexes(words, aiV, indexes, 0, indexes.csize);
	if (err.csize) return (err, -pos);

	aiPhrases aiP = aiPhrasesCreate();

	err = aiP.methods.parseWords(aiP, aiV, words);
	if (err.csize) return (err, 6);

	char out[];
	int nPhrases;
	(err, nPhrases) = aiP.methods.printTopPhrases(out, aiP, aiV, letters, data.nPhrases);
	if (err.csize) return (err, 7);

	strcat(out, "Total ");
	printint(out, nPhrases, 1);
	strcat(out, " phrases.\r\n");

	return (out, 0);
}

(volatile parserData data, const char text[], int status) -> () inputRead = {
	if (status < 0 || status + data.input.csize == 0) {
		outputp("", "", "Error reading input file.\r\n");
		return;
	}

	if (status)
		strcat(data.input, text);

	if (status == 0x100000) {
		read(code, data, data.inputFile, data.input.csize, 0x100000);
		return;
	}

	char res[];
	(res, status) = processText(data, data.input);

	if (status) {
		char out[];
		strcat(out, res);
		strcat(out," (position ");
		printint(out, -status, 1);
		strcat(out, ")\r\n");
		res = out;
	}

	outputp("", "", res);
	return;
};

(const char inputFile[], const char codeTable[], int nPhrases) -> () topPhrases = {
	parserData data;

	data.inputFile = inputFile;
	data.codeTable = codeTable;
	data.nPhrases = nPhrases;

	read(inputRead, data, inputFile, 0, 0x100000);
	return;
};
