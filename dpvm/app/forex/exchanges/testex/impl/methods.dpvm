/* testex class, methods implementation, T20.040-T20.075; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.1, T19.354-T19.744 */

#include "../../../../../lib/stdlib/stdlib.dpvmake"
#include "../../../../../tools/registry/registry.dpvmake"
#include "../../../../../lib/math/rand/rand.dpvmake"
#include "../../../forexConstants.dpvmh"
#include "testex.dpvmake"
#include "version.dpvmh"

int registryMask = REGISTRY_COMPILER;	/* mask of registry applications used by testex class */

(volatile stateful any testexObj) -> (const char error[], int flags) getFlags = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any testexObj, int flags) -> (const char error[]) setFlags = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any testexObj, const stateful any registry) -> (const char error[]) setRegistry = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(volatile stateful any testexObj, const char publicKey[], const char privateKey[]) -> (const char error[]) setKey = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "setKey");
	if (err.csize) return err;

	randObj.initObj(impl.data.rand, {publicKey, privateKey, impl});

	return "";
};

(volatile stateful any testexObj, float price) -> (const char error[]) setTestPrice = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "setTestPrice");
	if (err.csize) return err;

	if (price < 0) {
		return mkError("negative price", "setTestPrice");
	}

	impl.data.price = price;

	if (!impl.data.balancesSet) {
		impl.data.balances[2] = ORDER_MIN * (ORDERS_MAX / 2 + 10);
		impl.data.balances[0] = impl.data.balances[2] * price;
		impl.data.balancesSet = 1;
		randObj.initObj(impl.data.rand, {impl});
	}

	int i;
	for (i = 0; i < impl.data.orders.lsize; i += 1) {
		testexOrder ord = impl.data.orders[i];
		float newprice = price;
		int done;

		if (ord.orderType == ORDER_TYPE_MARKET) {
			if (ord.direction == ORDER_DIRECTION_BUY || ord.direction == ORDER_DIRECTION_SELL)
				done = 1;
		} else if (ord.orderType == ORDER_TYPE_LIMIT) {
			if (ord.direction == ORDER_DIRECTION_BUY)
				done = ord.price >= price;
			else if (ord.direction == ORDER_DIRECTION_SELL)
				done = ord.price <= price;
			newprice = ord.price;
		} else if (ord.orderType == ORDER_TYPE_STOP_LOSS) {
			if (ord.direction == ORDER_DIRECTION_BUY)
				done = ord.price <= price;
			else if (ord.direction == ORDER_DIRECTION_SELL)
				done = ord.price >= price;
		}

		if (done) {
			float amount = ord.volume * ord.price, newamount = ord.volume * newprice, fee;
			if (ord.orderType != ORDER_TYPE_LIMIT)
				fee = newamount * ORDER_TAKER_FEE;
			else
				fee = newamount * ORDER_MAKER_FEE;

			if (ord.direction == ORDER_DIRECTION_BUY) {
				impl.data.balances[1] -= amount;
				fee += newamount - amount;
				if (impl.data.balances[0] >= fee) {
					impl.data.balances[0] -= fee;
					impl.data.balances[2] += ord.volume;
				} else
					impl.data.balances[0] += amount;
			} else if (ord.direction == ORDER_DIRECTION_SELL) {
				impl.data.balances[3] -= ord.volume;
				impl.data.balances[0] += newamount - fee;
			}

			ord.price = newprice;
			impl.data.executed.lpush(ord);

			impl.data.orders[i] = impl.data.orders[impl.data.orders.lsize - 1];
			impl.data.orders.lpop(1);
			i -= 1;
		}
	}

	return "";
};

(volatile stateful float out[], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencyPair[], int startTime, int interval) -> () getData = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "getData");
	if (err.csize) return callback(data, err);

	return callback(data, mkError("not implemented", "getData"));
};

(volatile stateful float out[], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencies[][]) -> () getBalances = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "getBalances");
	if (err.csize) return callback(data, err);

	if (currencies.lsize != 2 || currencies[0] != "USD") {
		return callback(data, mkError("illegal currencies", "getBalances"));
	}

	out.fpush(impl.data.balances[0] + impl.data.balances[1]);
	out.fpush(impl.data.balances[1]);
	out.fpush(impl.data.balances[2] + impl.data.balances[3]);
	out.fpush(impl.data.balances[3]);
	return callback(data, "");
};

(volatile stateful char out[], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencyPair[], int orderType, int direction, float volume, float price) -> () addOrder = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "addOrder");
	if (err.csize) return callback(data, err);

	if (orderType != ORDER_TYPE_MARKET && orderType != ORDER_TYPE_LIMIT && orderType != ORDER_TYPE_STOP_LOSS) {
		return callback(data, mkError("illegal order type", "addOrder"));
	}

	if (direction != ORDER_DIRECTION_BUY && direction != ORDER_DIRECTION_SELL) {
		return callback(data, mkError("illegal order direction", "addOrder"));
	}

	if (price <= 0) {
		return callback(data, mkError("illegal order price", "addOrder"));
	}

	if (impl.data.orders.lsize >= ORDERS_MAX) {
		return callback(data, mkError("maximum orders number exceeded", "addOrder"));
	}

	if (volume < ORDER_MIN) {
		return callback(data, mkError("too low order volume", "addOrder"));
	}

	if (direction == ORDER_DIRECTION_BUY) {
		if (impl.data.balances[0] < volume * price)
			return callback(data, mkError("unsufficient funds", "addOrder"));
		impl.data.balances[0] -= volume * price;
		impl.data.balances[1] += volume * price;
	} else if (direction == ORDER_DIRECTION_SELL) {
		if (impl.data.balances[2] < volume)
			return callback(data, mkError("unsufficient funds", "addOrder"));
		impl.data.balances[2] -= volume;
		impl.data.balances[3] += volume;
	}

	const char chars[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	char txid[];
	int i;
	for (i = 0; i < 19; i += 1) {
		if (i == 6 || i == 12)
			txid.cpush('-');
		else
			txid.cpush(chars[randObj.getLimited(impl.data.rand, chars.csize)]);
	}

	testexOrder ord = {txid, orderType, direction, volume, price};
	impl.data.orders.lpush(ord);
	strcat(out, txid);

	return callback(data, "");
};

(volatile stateful char txids[][], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencyPair[]) -> () listOrders = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "listOrders");
	if (err.csize) return callback(data, err);

	int i;
	for (i = 0; i < impl.data.orders.lsize; i += 1)
		txids.lpush(impl.data.orders[i].txid);

	const type internalData = {
		const (volatile stateful any data, const char error[]) -> () callback;
		volatile stateful any data;
	};

	const (volatile stateful internalData d, const int values[]) -> () internalCallback = {
		return d.callback(d.data, "");
	};

	const int vars[] = {};
	internalData d = {callback, data};
	return getsys(internalCallback, d, vars);
};

(volatile stateful int status[], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char txid[]) -> () getOrderStatus = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "getOrderStatus");
	if (err.csize) return callback(data, err);

	int i;
	for (i = 0; i < impl.data.executed.lsize; i += 1) {
		testexOrder ord = impl.data.executed[i];
		if (ord.txid == txid) {
			impl.data.executed[i] = impl.data.executed[impl.data.executed.lsize - 1];
			impl.data.executed.lpop(1);
			status.ipush(ORDER_STATUS_EXECUTED);
			return callback(data, "");
		}
	}

	for (i = 0; i < impl.data.orders.lsize; i += 1) {
		testexOrder ord = impl.data.orders[i];
		if (ord.txid == txid) {
			status.ipush(ORDER_STATUS_OPEN);
			return callback(data, "");
		}
	}

	status.ipush(ORDER_STATUS_UNKNOWN);
	return callback(data, "");
}

(volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char txid[]) -> () cancelOrder = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "cancelOrder");
	if (err.csize) return callback(data, err);

	int i;
	for (i = 0; i < impl.data.orders.lsize; i += 1) {
		testexOrder ord = impl.data.orders[i];
		if (ord.txid == txid) {
			if (ord.direction == ORDER_DIRECTION_BUY) {
				impl.data.balances[0] += ord.volume * ord.price;
				impl.data.balances[1] -= ord.volume * ord.price;
			} else if (ord.direction == ORDER_DIRECTION_SELL) {
				impl.data.balances[2] += ord.volume;
				impl.data.balances[3] -= ord.volume;
			}
			impl.data.orders[i] = impl.data.orders[impl.data.orders.lsize - 1];
			impl.data.orders.lpop(1);
			return callback(data, "");
		}
	}

	return callback(data, mkError("order not found", "cancelOrder"));
};

(volatile stateful int count[], volatile stateful any testexObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data)
		-> () cancelAll = {
	testexImpl impl;
	char err[] = convertObjToImpl(impl, testexObj, "cancelOrder");
	if (err.csize) return callback(data, err);

	count.ipush(impl.data.orders.lsize);

	int i;
	for (i = 0; i < impl.data.orders.lsize; i += 1) {
		testexOrder ord = impl.data.orders[i];
		if (ord.direction == ORDER_DIRECTION_BUY) {
			impl.data.balances[0] += ord.volume * ord.price;
			impl.data.balances[1] -= ord.volume * ord.price;
		} else if (ord.direction == ORDER_DIRECTION_SELL) {
			impl.data.balances[2] += ord.volume;
			impl.data.balances[3] -= ord.volume;
		}
		impl.data.orders[i] = impl.data.orders[impl.data.orders.lsize - 1];
		impl.data.orders.lpop(1);
		i -= 1;
	}

	return callback(data, "");
};

testexMethods testexMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setRegistry,
	setKey,
	setTestPrice,
	getData,
	getBalances,
	addOrder,
	listOrders,
	getOrderStatus,
	cancelOrder,
	cancelAll,
	dump
};
