/* kraken class, getData() method implementation, T19.829-T19.994; $DVS:time$ */

int _Z = 0;
#include "../../../../../common/mpopenFlags.dpvmh"
#include "../../../../../lib/stdlib/stdlib.dpvmake"
#include "../../../../../lib/math/crypto/json/json.dpvmake"
#include "kraken.dpvmh"

int TIMEOUT = 60000000000;

type getDataData = {
	volatile stateful float out[];
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	const char currencyPair[];
	volatile char text[];
	int startTime;
	int interval;
};

(volatile stateful getDataData d, const char text[], int status) -> () inputCallback = {
	if (status < 0 && !d.text.csize) {
		char error[];
		printf(error, "Input failed: error %d.", {status});
		d.callback(d.data, error);
		return;
	}
	if (status > 0) {
		strcat(d.text, text);
		input(code, d, 0x100000, TIMEOUT);
		return;
	}
	if (!d.text.csize) {
		d.callback(d.data, "Empty output.");
		return;
	}

	jsonClass json = jsonCreate();
	jsonMethods j = json.methods;
	jsonObject obj;
	char error[];
	int next;
	(obj, error, next) = j.deserialize(d.text, 0, d.text.csize);
	if (error.csize) {
		d.callback(d.data, error);
		return;
	}
	jsonObject err = j.getObjectByIndex(j.getObjectByName(obj, "error"), 0);
	if (!j.isNull(err)) {
		char e[];
		error = j.getString(e, err);
		if (error.csize)
			d.callback(d.data, error);
		else
			d.callback(d.data, e);
		return;
	}

	jsonObject res = j.getObjectByIndex(j.getObjectByName(obj, "result"), 0);
	if (j.isNull(res)) {
		d.callback(d.data, "No result found");
		return;
	}

	int i, end, last;

	(error, last) = j.getInt(j.getObjectByName(j.getObjectByName(obj, "result"), "last"));
	if (error.csize) {
		d.callback(d.data, error);
		return;
	}

	for (i = 0; !end; i += 1) {
		jsonObject item = j.getObjectByIndex(res, i);
		if (j.isNull(item))
			end = 1;
		else {
			int k, time, n;
			float f, arr[];
			for (k = 0; k < DATA_ITEM_END; k += 1) {
				jsonObject field = j.getObjectByIndex(item, k);
				if (k == DATA_TIMESTAMP || k == DATA_TRANSACTIONS) {
					(error, n) = j.getInt(field);
					if (k == DATA_TIMESTAMP)
						time = n;
					f = n;
				} else {
					char str[];
					error = j.getString(str, field);
					if (!error.csize) {
						any x;
						scanf(x, "%f", str, 0, str.csize);
						if (x.fsize)
							f = x.f[0];
						else
							error = "Float not found in string";
					}
				}
				if (error.csize) {
					d.callback(d.data, error);
					return;
				}
				arr.fpush(f);
			}
			if (time >= d.startTime / 1000000000 && time <= last) {
				for (k = 0; k < DATA_ITEM_END; k += 1)
					d.out.fpush(arr[k]);
			}
		}
	}

	d.callback(d.data, "");
	return;
};

(volatile stateful getDataData d, int status) -> () mpopenCallback = {
	if (status != DPVM_MPOPEN_READ) {
		char error[];
		printf(error, "Mpopen failed: error %d.", {status});
		d.callback(d.data, error);
		return;
	}
	char text[];
	d.text = text;
	input(inputCallback, d, 0x100000, TIMEOUT);
	return;
};

(volatile stateful float out[], volatile stateful any krakenObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencyPair[], int startTime, int interval) -> () getData = {
	char text[];
	getDataData d = {out, callback, data, currencyPair, text, startTime, interval};

	char request[];
	printf(request, "%sOHLC?pair=%s&interval=%d&since=%d", {PUBLIC_URL, currencyPair,
		interval / 60000000000, startTime / 1000000000});
	char args[][];
	args.lpush("--header=Accept: application/json");
	args.lpush("--timeout=60");
	args.lpush("-qO-");
	args.lpush(request);
	mpopen(mpopenCallback, d, WGET_BIN, args, DPVM_MPOPEN_READ);
	return;
};
