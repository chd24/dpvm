/* kraken class, listOrders() method implementation, T19.829-T20.040; $DVS:time$ */

int _Z = 0;
#include "../../../../../common/sysParams.dpvmh"
#include "../../../../../common/mpopenFlags.dpvmh"
#include "../../../../../lib/stdlib/stdlib.dpvmake"
#include "../../../../../lib/math/crypto/json/json.dpvmake"
#include "kraken.dpvmake"

int TIMEOUT = 60000000000;

type requestData = {
	volatile stateful krakenImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	volatile stateful char txids[][];
	volatile char text[];
	const char currencyPair[];
};

(volatile stateful requestData d, const char text[], int status) -> () inputCallback = {
	if (status < 0 && !d.text.csize) {
		char error[];
		printf(error, "Input failed: error %d.", {status});
		d.callback(d.data, error);
		return;
	}
	if (status > 0) {
		strcat(d.text, text);
		input(code, d, 0x100000, TIMEOUT);
		return;
	}
	if (!d.text.csize) {
		d.callback(d.data, "Empty output.");
		return;
	}

	jsonClass json = jsonCreate();
	jsonMethods j = json.methods;
	jsonObject obj;
	char error[];
	int next;
	(obj, error, next) = j.deserialize(d.text, 0, d.text.csize);
	if (error.csize) {
		d.callback(d.data, error);
		return;
	}
	jsonObject err = j.getObjectByIndex(j.getObjectByName(obj, "error"), 0);
	if (!j.isNull(err)) {
		char e[];
		error = j.getString(e, err);
		if (error.csize)
			d.callback(d.data, error);
		else
			d.callback(d.data, e);
		return;
	}

	int i;
	for (i = 0; i >= 0; i += 1) {
		jsonObject ord = j.getObjectByIndex(j.getObjectByName(j.getObjectByName(obj, "result"), "open"), i);
		if (j.isNull(ord))
			i = -2;
		else {
			char ordStatus[];
			error = j.getString(ordStatus, j.getObjectByName(ord, "status"));
			if (!error.csize && (ordStatus == "open" || ordStatus == "pending")) {
				char pair[];
				error = j.getString(pair, j.getObjectByName(j.getObjectByName(ord, "descr"), "pair"));
				if (!error.csize && pair == d.currencyPair) {
					char name[];
					error = j.getName(name, ord);
					if (!error.csize)
						d.txids.lpush(name);
				}
			}
			if (error.csize) {
				d.callback(d.data, error);
				return;
			}
		}
	}

	d.callback(d.data, "");
	return;
};

(volatile stateful requestData d, int status) -> () mpopenCallback = {
	if (status != DPVM_MPOPEN_READ) {
		char error[];
		printf(error, "Mpopen failed: error %d.", {status});
		d.callback(d.data, error);
		return;
	}
	char text[];
	d.text = text;
	input(inputCallback, d, 0x100000, TIMEOUT);
	return;
};

(volatile stateful requestData d, const int values[]) -> () timeCallback = {
	d.impl.data.nonce = values[0];

	char args[][];
	char error[];
	(args, error) = formPrivateQuery(d.impl, "OpenOrders", "");
	mpopen(mpopenCallback, d, WGET_BIN, args, DPVM_MPOPEN_READ);
	return;
};

(volatile stateful char txids[][], volatile stateful any krakenObj,
		const (volatile stateful any data, const char error[]) -> () callback, volatile stateful any data,
		const char currencyPair[]) -> () listOrders = {
	krakenImpl impl;
	char err[] = convertObjToImpl(impl, krakenObj, "listOrders");
	if (err.csize) {
		callback(data, err);
		return;
	}

	char text[];
	requestData d = {impl, callback, data, txids, text, currencyPair};

	const int vars[] = {DPVM_SYS_PARAM_TIME};
	int values[] = {impl.data.nonce + REQUEST_INTERVAL};
	setsys(timeCallback, d, vars, values);
	return;

}
