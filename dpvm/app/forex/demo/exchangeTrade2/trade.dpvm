/* forex class */

int _Z = 0;
#include "../../../../common/sysParams.dpvmh"
#include "../../../../common/taskFlags.dpvmh"
#include "../../../../lib/stdlib/stdlib.dpvmake"
#include "../../../../lib/utils/utils.dpvmake"
#include "../../../../lib/math/rand/rand.dpvmake"
#include "../../../../lib/config/config.dpvmake"
#include "../../forex.dpvmake"
#include "trade.dpvmh"

const char version[]	= "exchangeTrade2 demo, T19.772-T20.164"; /* $DVS:time$ */

int CYCLE_PERIOD_GAP	= 10000000000;

type demoData = {
	const tradeConfig cd;
	volatile forexClass forexObj;
	volatile stateful inputFile fl;
	volatile randData rand;
	int time;
	int cycle;
	int phase;
	int sumOrdersCycles;
	int inputDataEnd;
	int maxInputDataEnd;
	int skipTraining;
};


/*************************
 * PREDICTION ALGORITHMS *
 *************************/

(const any data, const stateful float inputData[], int end, int inputDataSize) -> (int output)
infinityLimitLossOutputCallback = {
	tradeConfig arr[];
	pushObject(data, arr);
	tradeConfig d = arr[0];
	float base = inputData[end - 1], downLimit = base * d.downRateCoeff, upLimit = base * d.upRateCoeff;
	int i, size = inputDataSize;
	for (i = end; i < size; i += 1) {
		if (inputData[i] >= upLimit)
			return 2;
		if (inputData[i] <= downLimit)
			return 1;
	}
	return 0;

},
outputCallbacks[] = {
	infinityLimitLossOutputCallback
};


/********************
 * ORDER ALGORITHMS *
 ********************/

(volatile stateful demoData d, int output) -> (const char error[])
infinityLimitStopLossOrderAlgo = {
	int currencyFrom = 1 - output, currencyTo = output, expirationTime, orders, ordersMax, ordersPending,
		ordersClosed;
	float amountFrom, amountTo, rate, volume = d.cd.orderVolume, upVolume = volume, downVolume = volume;
	char error[];

	(error, amountFrom) = d.forexObj.methods.getBalance(d.forexObj, currencyFrom, BALANCE_TYPE_FREE);
	if (error.csize) return error;
	(error, amountTo) = d.forexObj.methods.getBalance(d.forexObj, currencyTo, BALANCE_TYPE_FREE);
	if (error.csize) return error;
	(error, rate) = d.forexObj.methods.getCurrentRate(d.forexObj, currencyFrom, currencyTo);
	if (error.csize) return error;
	(error, expirationTime) = d.forexObj.methods.getCurrentTime(d.forexObj);
	if (error.csize) return error;
	(error, orders, ordersMax, ordersPending, ordersClosed) = d.forexObj.methods.getOrdersStatistics(d.forexObj);
	if (error.csize) return error;

	d.sumOrdersCycles += orders;
	int sumOrdersCycles = d.sumOrdersCycles;
	if (sumOrdersCycles <= 0) sumOrdersCycles = 1;
	int nOrders = (orders + ordersClosed) * 2 / 3;
	if (nOrders <= 0) nOrders = 1;
	float prob = nOrders * 1.0 / sumOrdersCycles * ordersMax / 2;
	float rnd = (randObj.getFloat(d.rand) + 1) / 2;

	if (!output) {
		amountTo *= rate;
		rate = 1 / rate;
	} else {
		amountFrom /= rate;
	}
	float downRate = rate * d.cd.downRateCoeff, upRate = rate * d.cd.upRateCoeff;
	int result = (amountFrom >= 2 * volume && amountTo >= 2 * volume && orders + ordersPending + 2 <= ordersMax
			&& rnd <= prob);
	char out[];
	printf(out, "OrderAlgo: dir=%d down/rate/up=%8.2f/%8.2f/%8.2f from/vol/to=%8.5f/%8.5f/%8.5f ord/max/pend/clos=%d/%d/%d/%d rand/pr/res=%.4f/%.4f/%d",
		{output, orders, ordersMax, ordersPending, ordersClosed, result,
		downRate + 0.004, rate + 0.004, upRate + 0.004,
		amountFrom + 0.0000004, volume + 0.0000004, amountTo + 0.0000004, rnd, prob});
	d.forexObj.methods.logOutput(d.forexObj, out, 8);
	if (!result)
		return "";
	if (!output) {
		(downRate, upRate) = (1 / upRate, 1 / downRate);
		upVolume /= upRate;
		downVolume /= downRate;
	} else {
		volume *= rate;
		rate = 1 / rate;
	}

	const type orderData = {
		const forexMethods methods;
		int currencyFrom;
		int currencyTo;
		int expirationTime;
		int limitOrderId;
		int stopLossOrderId;
		float downVolume;
		float upVolume;
		float downRate;
		float upRate;
	};

	const (volatile stateful any forexObj, const stateful any order, int action) -> ()
	callbackSellLimit = {
		if (action == ORDER_ACTION_EXECUTED) {
			forexOrder oarr[];
			pushObject(order, oarr);
			forexOrder ord = oarr[0];

			orderData darr[];
			pushObject(ord.data, darr);
			orderData data = darr[0];

			data.methods.cancelOrder(forexObj, data.stopLossOrderId);
		}
		return;
	},
	callbackSellStopLoss = {
		if (action == ORDER_ACTION_EXECUTED) {
			forexOrder oarr[];
			pushObject(order, oarr);
			forexOrder ord = oarr[0];

			orderData darr[];
			pushObject(ord.data, darr);
			orderData data = darr[0];

			data.methods.cancelOrder(forexObj, data.limitOrderId);
		}
		return;
	},
	callbackBuy = {
		if (action == ORDER_ACTION_EXECUTED) {
			forexOrder oarr[];
			pushObject(order, oarr);
			forexOrder ord = oarr[0];

			orderData darr[];
			pushObject(ord.data, darr);
			orderData data = darr[0];

			forexOrder orderSellLimit = {callbackSellLimit, darr[0], "", 0, ORDER_TYPE_LIMIT,
					data.currencyTo, data.currencyFrom, data.expirationTime,
					data.upVolume, data.upRate};
			forexOrder orderSellStopLoss = {callbackSellStopLoss, darr[0], "", 0, ORDER_TYPE_STOP_LOSS,
					data.currencyTo, data.currencyFrom, data.expirationTime,
					data.downVolume, data.downRate};

			char error[] = data.methods.putOrderExt(forexObj, orderSellLimit);
			if (error.csize) return;
			error = data.methods.putOrderExt(forexObj, orderSellStopLoss);
			if (error.csize) data.methods.cancelOrder(forexObj, orderSellLimit.id);
			else {
				data.limitOrderId = orderSellLimit.id;
				data.stopLossOrderId = orderSellStopLoss.id;
			}
		}
		return;
	};

	orderData data = {d.forexObj.methods, currencyFrom, currencyTo, -1 >> 1, 0, 0,
			downVolume, upVolume, downRate, upRate};

	forexOrder orderBuy = {callbackBuy, data, "", 0, ORDER_TYPE_MARKET, currencyFrom, currencyTo,
			expirationTime, volume, rate};

	return d.forexObj.methods.putOrderExt(d.forexObj, orderBuy);
},
orderAlgorithms[] = {
	infinityLimitStopLossOrderAlgo
};


/*****************
 * MAIN ROUTINES *
 *****************/

(volatile stateful any data, const char error[]) -> () callback = {
	demoData darr[];
	pushObject(data, darr);
	demoData d = darr[0];

	if (error.csize) {
		char out[];
		printf(out, "%s\r\n", {error});
		d.forexObj.methods.logOutput(d.forexObj, out, 4);
	}

	if (!d.phase) {
		if (!(d.cycle % d.cd.dumpCycles)) {
			char out[];
			int level = 7;
			error = d.forexObj.methods.dump(out, d.forexObj, d.cd.graphX, d.cd.graphY);
			if (error.csize)
				printf(out, "%s\r\n", {error}), level = 4;
			d.forexObj.methods.logOutput(d.forexObj, out, level);
		}

		(error, d.maxInputDataEnd) = d.forexObj.methods.getInputDataEnd(d.forexObj);
		if (error.csize) {
			char out[];
			printf(out, "%s\r\n", {error});
			d.forexObj.methods.logOutput(d.forexObj, out, 4);
		}

		if (!d.cycle) {
			d.inputDataEnd = d.maxInputDataEnd - d.cd.replayHistoricCycles;
			if (d.inputDataEnd < 0)
				d.inputDataEnd = 0;
			d.time -= (d.maxInputDataEnd - d.inputDataEnd) * d.cd.cyclePeriod;

			error = d.forexObj.methods.setInputDataEnd(d.forexObj, d.inputDataEnd);
			if (error.csize) {
				char out[];
				printf(out, "%s\r\n", {error});
				d.forexObj.methods.logOutput(d.forexObj, out, 4);
			}
		} else {
			d.skipTraining = d.maxInputDataEnd <= d.inputDataEnd;
			d.inputDataEnd = d.maxInputDataEnd;
		}
	}

	d.phase += 1;

	if (d.phase == 3) {
		d.time += d.cd.cyclePeriod;
		const int vars[] = {DPVM_SYS_PARAM_TIME};
		int values[] = {d.time};
		setsysp("", "", vars, values);

		d.phase = 0;
		d.cycle += 1;

		if (d.inputDataEnd >= d.maxInputDataEnd) {
			if (d.cd.inputDataFormat)
				d.forexObj.methods.readCsvData(d.forexObj, code, d, d.fl, d.cd.inputValuesPerLine);
			else
				d.forexObj.methods.readCryptoLog(d.forexObj, code, d, d.fl, d.cd.nCurrency);
			return;
		}

		d.inputDataEnd += 1;
		error = d.forexObj.methods.setInputDataEnd(d.forexObj, d.inputDataEnd);
		if (error.csize) {
			char out[];
			printf(out, "%s\r\n", {error});
			d.forexObj.methods.logOutput(d.forexObj, out, 4);
		}
		d.phase += 1;
	}

	if (d.phase == 1) {
		d.phase += d.skipTraining;
		d.forexObj.methods.syncExchange(d.forexObj, code, d, SYNC_SET_TEST_ALL * (d.skipTraining == 0)
			| SYNC_CANCEL_ALL * (d.cycle == 0) | SYNC_SHOW_STAT * (d.skipTraining == 1));
		return;

	}

	error = d.forexObj.methods.neuronTraining(d.forexObj, d.cd.neuronNet, d.cd.trainingParams, d.cd.inputDataPartPerCycle == 1,
			d.cd.inputDataPartPerCycle == 1 ? 1 : -d.cd.inputDataPartPerCycle, d.cd.neuronFlags);
	if (error == "0" || error == "1" || error == "2" || error == "3") {
		int output = (error[0] - '0'), orderAlgo = d.cd.orderAlgorithm;
		error = "";
		if (output & 1)
			error = orderAlgorithms[orderAlgo](d, 0);
		if (!error.csize && output & 2)
			error = orderAlgorithms[orderAlgo](d, 1);
	} else if (!error.csize)
		error = "No expected prediction from neuron net";

	if (error.csize) {
		char out[];
		printf(out, "%s\r\n", {error}),
		d.forexObj.methods.logOutput(d.forexObj, out, 4);
	}

	d.forexObj.methods.syncExchange(d.forexObj, code, d, SYNC_SHOW_STAT);
	return;
};

(volatile stateful demoData d, const char text[], int status) -> () inputCallback = {
	configClass configObjs[];
	pushObject(d.cd.configObj, configObjs);
	configClass configObj = configObjs[0];

	int flags;
	char error[];
	if (status <= 0)
		error = "Error: empty private key.";
	if (!error.csize)
		(error, flags) = configObj.methods.getFlags(configObj);
	if (!error.csize && flags & CONFIG_FLAG_INPUT)
		error = configObj.methods.endInput(configObj);
	if (!error.csize)
		error = d.forexObj.methods.setExchange(d.forexObj, d.cd.exchangeName, d.cd.publicKey, text, d.cd.currencies);
	if (!error.csize)
		error = d.forexObj.methods.setFlags(d.forexObj, d.cd.forexFlags);
	if (!error.csize)
		error = d.forexObj.methods.setRegistry(d.forexObj, d.cd.registry);
	if (!error.csize)
		error = d.forexObj.methods.runLogger(d.forexObj, d.cd.logFileName, d.cd.taskId);
	if (error.csize)
		return d.forexObj.methods.logOutput(d.forexObj, error, 1);

	char out[];
	printf(out, "Starting %s (%p) based on %s", {version, d.cd.demo, d.forexObj.methods.version});
	d.forexObj.methods.logOutput(d.forexObj, out, 6);

	int outputAlgo = d.cd.predictionAlgorithm;
	if (outputAlgo < 0 || outputAlgo >= outputCallbacks.lsize)
		return d.forexObj.methods.logOutput(d.forexObj, "Error: unknown prediction algorithm", 1);

	int orderAlgo = d.cd.orderAlgorithm;
	if (orderAlgo < 0 || orderAlgo >= orderAlgorithms.lsize)
		return d.forexObj.methods.logOutput(d.forexObj, "Error: unknown order algorithm", 1);

	error = d.forexObj.methods.setOutputCallback(d.forexObj, outputCallbacks[outputAlgo], d.cd);
	if (error.csize)
		return d.forexObj.methods.logOutput(d.forexObj, error, 1);

	if (d.cd.inputDataFormat)
		d.forexObj.methods.readCsvData(d.forexObj, callback, d, d.fl, d.cd.inputValuesPerLine);
	else
		d.forexObj.methods.readCryptoLog(d.forexObj, callback, d, d.fl, d.cd.nCurrency);
	return;
};

(const char error[]) -> () initError = {
	char mess[];
	printf(mess, "%s: initialization error: %s\r\n", {version, error});
	outputp("", "", mess);
	return;
};

(const any cfg, const char error[]) -> () loadpCallback = {
	if (error.csize)
		return initError(error);

	tradeConfig configs[];
	pushObject(cfg, configs);
	tradeConfig cd = configs[0];

	inputFile f = {cd.inputDataFileName};
	demoData d = {cd, forexCreate(), f};

	d.time = cd.startTime;
	randObj.initObj(d.rand, {d});

	configClass configObjs[];
	pushObject(cd.configObj, configObjs);
	configClass configObj = configObjs[0];

	int flags;
	(error, flags) = configObj.methods.getFlags(configObj);
	if (error.csize) return d.forexObj.methods.logOutput(d.forexObj, error, 1);

	if (flags & CONFIG_FLAG_INPUT) {
		const int vars[] = {DPVM_SYS_PARAM_FLAGS};
		const int flag = DPVM_TASK_FLAG_NO_INPUT_HISTORY + DPVM_TASK_FLAG_NO_INPUT_ECHO;
		const int values[] = {flag};
		setsysp("", "", vars, values);

		outputp("", "", "Private key: ");

		input(inputCallback, d, 256, -1);
	} else
		inputCallback(d, cd.privateKey, cd.privateKey.csize);

	return;
};

(const any registry, const char configFileName[], int inputPrivateKey) -> () exchangeTrade2 = {
	configClass configObj = configCreate();

	char error[] = configObj.methods.setFlags(configObj, inputPrivateKey * CONFIG_FLAG_INPUT);
	if (!error.csize) error = configObj.methods.setRegistry(configObj, registry);
	if (!error.csize) error = configObj.methods.setFunction(configObj, code);
	if (!error.csize) error = configObj.methods.addHeader(configObj, "../dpvm/app/forex/demo/exchangeTrade2/trade.dpvmh");
	if (!error.csize) error = configObj.methods.addConfigFile(configObj, "[defaultConfig]", "
/* default configuration */
configObj = __CONFIG__
demo = __FUNCTION__
registry = __REGISTRY__
startTime = __TIME__
taskId = __TASKID__
inputDataFormat = 1
inputValuesPerLine = 4
nCurrency = 2
cyclePeriod = 15*60*1000000000
dumpCycles = 24*4
graphX = 197
graphY = 40
");
	if (!error.csize) error = configObj.methods.addConfig(configObj, "../dpvm/app/forex/demo/exchangeTrade2/trade.dpvmc");
	if (!error.csize) error = configObj.methods.addConfig(configObj, configFileName);

	if (error.csize) return initError(error);

	return configObj.methods.loadp(configObj, loadpCallback, "tradeConfig");

};
