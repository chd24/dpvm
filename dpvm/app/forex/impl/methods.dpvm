/* forex class, methods implementation, T19.744-T20.040; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.1, T19.354-T19.744 */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "../../../lib/utils/utils.dpvmake"
#include "../../../tools/registry/registry.dpvmake"
#include "../exchanges/exchanges.dpvmake"
#include "forex.dpvmake"
#include "version.dpvmh"

int registryMask = REGISTRY_COMPILER;	/* mask of registry applications used by forex class */

(const stateful any forexObj) -> (const char error[], int flags) getFlags = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any forexObj, int flags) -> (const char error[]) setFlags = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any forexObj, const stateful any registry) -> (const char error[]) setRegistry = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(const stateful any forexObj) -> (const char error[], int time) getCurrentTime = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getCurrentTime");
	if (err.csize) return (err, 0);

	if (!impl.data.lastFileTime)
		return (mkError("time not set", "getCurrentTime"), 0);

	return ("", impl.data.lastFileTime);
};

(const stateful any forexObj) -> (const char error[], int nEntries) getInputDataEnd = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getInputDataEnd");
	if (err.csize) return (err, 0);

	return ("", impl.data.inputDataEnd / impl.data.inputValuesPerSlot);
};

(const stateful any forexObj, int nEntries) -> (const char error[]) setInputDataEnd = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "setInputDataEnd");
	if (err.csize) return err;

	if (nEntries < 0 || nEntries > impl.data.inputData.fsize / impl.data.inputValuesPerSlot)
		return mkError("illegal input data end", "setInputDataEnd");

	impl.data.inputDataEnd = nEntries * impl.data.inputValuesPerSlot;

	if (impl.data.lastInputDataEnd > impl.data.inputDataEnd)
		impl.data.lastInputDataEnd = impl.data.inputDataEnd;

	return "";
};

(const stateful any forexObj, int currency, int balanceType) -> (const char error[], float amount) getBalance = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getBalance");
	if (err.csize) return (err, 0);

	if (currency < 0 || currency > 1)
		return (mkError("illegal currency", "getBalance"), 0);

	float res;
	if (balanceType & BALANCE_TYPE_FREE)
		res += impl.data.balance[currency];

	if (balanceType & BALANCE_TYPE_ORDERS) {
		int i;
		for (i = 0; i < impl.data.orders.lsize; i += 1)
			if (impl.data.orders[i].currencyFrom == currency)
				res += impl.data.orders[i].amount;
	}

	return ("", res);
};

(volatile stateful any forexObj, const stateful any order, int action) -> () defaultOrderCallback = {
	return;
};

(volatile stateful any forexObj, int currency, float amount) -> (const char error[]) addBalance = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "addBalance");
	if (err.csize) return err;

	if (currency < 0 || currency > 1)
		return mkError("illegal currency", "addBalance");

	if (amount + impl.data.balance[currency] < 0)
		return mkError("unsufficient balance", "addBalance");

	any data;
	forexOrder order = {defaultOrderCallback, data, "", impl.data.nextOrderId, ORDER_TYPE_LIMIT, currency, currency,
			0, amount, 1.0};
	impl.data.nextOrderId += 1;
	impl.data.orders.lpush(order);
	processOrder(impl, impl.data.orders.lsize - 1, ORDER_ACTION_EXECUTED);
	return "";
};

(const stateful any forexObj, int currencyBase, int currency) -> (const char error[], float rate) getCurrentRate = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getCurrentRate");
	if (err.csize) return (err, 0);

	if (currencyBase < 0 || currencyBase > 1 || currency < 0 || currency > 1)
		return (mkError("illegal currency", "getCurrentRate"), 0);

	if (currency == currencyBase)
		return ("", 1);

	if (!impl.data.inputDataEnd)
		return (mkError("input data is not filled", "getCurrentRate"), 0);

	float rate = impl.data.inputData[impl.data.inputDataEnd - 1];

	if (currency)
		return ("", rate);
	return ("", 1/rate);
};

(const stateful any forexObj, int statMethod, int currencyBase, int currency, int begin, int end)
		-> (const char error[], float rate) getRateStatistics = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getRateStatistics");
	if (err.csize) return (err, 0);

	if (statMethod < 0 || statMethod >= statistics.lsize)
		return (mkError("illegal statistics method", "getRateStatistics"), 0);

	if (currencyBase < 0 || currencyBase > 1 || currency < 0 || currency > 1)
		return (mkError("illegal currency", "getRateStatistics"), 0);

	int size = impl.data.inputDataEnd / impl.data.inputValuesPerSlot;
	if (begin < 0) begin += size;
	if (end <= 0) end += size;

	if (0 > begin || begin >= end || end > size)
		return (mkError("illegal input data segment", "getRateStatistics"), 0);

	if (currency == currencyBase)
		return ("", 1);

	float rate = statistics.l[statMethod](impl.data.inputData, begin * impl.data.inputValuesPerSlot,
		end * impl.data.inputValuesPerSlot);

	if (currency)
		return ("", rate);
	return ("", 1/rate);
};

(const stateful any forexObj) -> (const char error[], int openOrders, int maxOpenOrders,
		int pendingClosedOrders, int closedOrders) getOrdersStatistics = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "getOrdersStatistics");
	if (err.csize) return (err, 0, 0, 0, 0);

	int max = (1 << 63) - 1;
	if (impl.data.exchangeSet)
		max = impl.data.maxOrders;

	return ("", impl.data.orders.lsize, max, impl.data.closedOrders.lsize, impl.data.nClosedOrders);
};

(volatile stateful any forexObj, const (const any data, const stateful float inputData[], int end, int inputdataSize)
		-> (int output) callback, const any data) -> (const char error[]) setOutputCallback = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "setOutputCallback");
	if (err.csize) return err;

	impl.data.outputCallback = callback;
	impl.data.outputCallbackData = data;
	impl.data.outputCallbackSet = 1;
	return "";
};

(volatile stateful any forexObj, const char exchangeName[], const char publicKey[], const char privateKey[],
		const char currencies[][]) -> (const char error[]) setExchange = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "setExchange");
	if (err.csize) return err;

	if (currencies.lsize < 2)
		return mkError("less than 2 currency names provided", "setExchange");

	int i;
	for (i = 0; i < allExchanges.lsize; i += 1) {
		if (allExchanges[i].name == exchangeName) {
			impl.data.exchange = allExchanges[i].create();
			err = impl.data.exchange.methods.setKey(impl.data.exchange, publicKey, privateKey);
			if (err.csize)
				return err;
			impl.data.maxOrders = allExchanges[i].maxOrders;
			impl.data.currencies = currencies;
			impl.data.exchangeSet = 1;
			return "";
		}
	}

	return mkError("exchange not found", "setExchange");
}

(volatile stateful any forexObj, volatile stateful forexOrder order) -> (const char error[]) putOrderExt = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "putOrderExt");
	if (err.csize) return err;

	if (order.currencyFrom < 0 || order.currencyFrom > 1 || order.currencyTo < 0 || order.currencyTo > 1)
		return mkError("illegal currency", "putOrderExt");

	if (order.orderType < 0 || order.orderType >= ORDER_TYPE_END)
		return mkError("illegal order type", "putOrderExt");

	if (order.amount > impl.data.balance[order.currencyFrom])
		return mkError("unsufficient balance", "putOrderExt");

	order.id = impl.data.nextOrderId;
	impl.data.nextOrderId += 1;
	impl.data.orders.lpush(order);
	processOrder(impl, impl.data.orders.lsize - 1, ORDER_ACTION_CREATED);
	processOrders(impl);

	return "";
};

(volatile stateful any forexObj, int orderType, int currencyFrom, int currencyTo, int expirationTimeFromNow,
		float amount, float rate) -> (const char error[]) putOrder = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "putOrder");
	if (err.csize) return err;

	any data;
	forexOrder order = {defaultOrderCallback, data, "", 0, orderType, currencyFrom, currencyTo,
			expirationTimeFromNow + impl.data.lastFileTime, amount, rate};

	return putOrderExt(impl, order);
};

(volatile stateful any forexObj, int orderId) -> (const char error[]) cancelOrder = {
	forexImpl impl;
	char err[] = convertObjToImpl(impl, forexObj, "calcelOrder");
	if (err.csize) return err;

	int i;
	for (i = 0; i < impl.data.orders.lsize; i += 1) {
		forexOrder order = impl.data.orders[i];

		if (order.id == orderId) {
			processOrder(impl, i, ORDER_ACTION_CANCELED);
			return "";
		}
	}

	return "";
};

forexMethods forexMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setRegistry,
	getCurrentTime,
	getInputDataEnd,
	setInputDataEnd,
	getBalance,
	addBalance,
	getCurrentRate,
	getRateStatistics,
	getOrdersStatistics,
	setOutputCallback,
	setExchange,
	logOutput,
	runLogger,
	syncExchange,
	putOrder,
	putOrderExt,
	cancelOrder,
	readCryptoLog,
	readCsvData,
	dump,
	neuronTraining
};
