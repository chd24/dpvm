/* forex class, readCryptoLog method implementation, T19.744-T19.837; $DVS:time$ */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "forex.dpvmake"

int READ_SIZE	= 0x100000;
int TIME_PERIOD = 600000000000;
int TIME_DIFF	= 2000000000;

type readData = {
	volatile stateful forexImpl impl;
	const (volatile stateful any data, const char error[]) -> () callback;
	volatile stateful any data;
	volatile stateful inputFile fl;
	const char body[];
	int nCurrency;
	int pos;
};

(int diff) -> (const char str[]) timeDiff2str = {
	char err[];
	if (diff < 0) {
		err.cpush('-');
		diff = -diff;
	} else {
		err.cpush(' ');
	}
	diff /= 60000000000;
	printf(err, "%d:%02d", {diff / 60, diff % 60});
	return err;
};

(volatile stateful readData d, const char err[]) -> () finish = {
	char mess[];
	printf(mess, "Read %d bytes, %d lines, produced %d values, min time gap %s, max time gap %s.\r\n",
		{timeDiff2str(d.fl.minTimeGap), timeDiff2str(d.fl.maxTimeGap), d.fl.bytes, d.fl.line, d.fl.values});
	logOutput(d.impl, mess, 6);
	d.callback(d.data, err);
	return;
};

(volatile stateful readData d, const char mess[], const char str[], int begin, int end) -> () printMess = {
	char err[];
	printf(err, "%s in line %5d pos %07x: ", {mess, d.fl.line, d.fl.pos - d.body.csize + d.pos});
	substrcat(err, str, begin, end);
	if (err[err.csize - 1] != '\n')
		strcat(err, "\r\n");
	logOutput(d.impl, err, 7);
	return;
};

(volatile stateful readData d, const char str[], int begin, int end) -> () processLine = {
	if (begin == end)
		return;
	any res;
	int n = scanf(res, "%d-%d-%d %d:%d:%d  total=$%f, btc=$%f, eth=$%f, xdag=$%f", str, begin, end);
	if (n < 6) {
		printMess(d, "UNFORMAT LINE", str, begin, end);
	} else {
		int time = make_time(res.i[0], res.i[1], res.i[2], res.i[3], res.i[4], res.i[5], 0);
		int diff = time - d.impl.data.lastFileTime;
		if (d.impl.data.lastFileTime && (diff <= TIME_PERIOD - TIME_DIFF || diff >= TIME_PERIOD + TIME_DIFF)) {
			char err[];
			printf(err, "TIME GAP%s", {timeDiff2str(diff)});
			printMess(d, err, str, begin, end);
			if (diff < d.fl.minTimeGap)
				d.fl.minTimeGap = diff;
			if (diff > d.fl.maxTimeGap)
				d.fl.maxTimeGap = diff;

			int step = 3600000000000;
			while (diff < 0) {
				diff += step;
				if (d.impl.data.firstTime)
					d.impl.data.firstTime -= step;
				if (d.impl.data.lastTime)
					d.impl.data.lastTime -= step;
			}
			if (diff > 2 * step) while (diff > step) {
				diff -= step;
				if (d.impl.data.firstTime)
					d.impl.data.firstTime += step;
				if (d.impl.data.lastTime)
					d.impl.data.lastTime += step;
			}
		}
		d.impl.data.lastFileTime = time;

		if (n > 6 + d.nCurrency) {
			diff = time - d.impl.data.lastTime;
			float value = res.f[d.nCurrency];
			if (d.impl.data.lastTime && (diff <= TIME_PERIOD - TIME_DIFF || diff >= TIME_PERIOD + TIME_DIFF)) {
				if (diff >= 2 * (TIME_PERIOD - TIME_DIFF)) {
					float oldvalue = d.impl.data.inputData.f[d.impl.data.inputData.fsize - 1];
					int dist = diff / (TIME_PERIOD - TIME_DIFF), i;
					for (i = 1; i < dist; i += 1) {
						d.impl.data.inputData.fpush(oldvalue + (value - oldvalue) * i / dist);
						d.fl.values += 1;
					}
				}
			}
			if (!d.impl.data.firstTime)
				d.impl.data.firstTime = time;
			d.impl.data.lastTime = time;
			d.impl.data.inputData.fpush(value);
			d.impl.data.inputDataEnd = d.impl.data.inputData.fsize;
			d.fl.values += 1;
		}
	}
	d.fl.line += 1;
	d.fl.bytes += end - begin;
	processOrders(d.impl);
	return;
};

(volatile stateful readData d, const char body[], int status) -> () readCallback = {
	if (status <= 0) {
		if (d.fl.pos == 0) {
			printMess(d, "EMPTY FILE  ", d.body, d.pos, d.body.csize);
			finish(d, mkError("empty file", "readCallback"));
			return;
		}
		if (status < 0)
			printMess(d, "READ ERROR  ", d.body, d.pos, d.body.csize);
		processLine(d, d.body, d.pos, d.body.csize);
		finish(d, "");
		return;
	}

	if (status == body.csize) {
		int pos = substrchr(body, 0, status, '\n');
		if (pos < 0)
			pos = status;
		else
			pos += 1;
		if (d.pos < d.body.csize) {
			char str[];
			substrcat(str, d.body, d.pos, d.body.csize);
			substrcat(str, body, 0, pos);
			processLine(d, str, 0, str.csize);
		} else
			processLine(d, body, 0, pos);

		d.body = body;
		d.pos = pos;
		d.fl.pos += status;

		do {
			pos = substrchr(d.body, d.pos, d.body.csize, '\n');
			if (pos >= 0) {
				pos += 1;
				processLine(d, d.body, d.pos, pos);
				d.pos = pos;
			}
		} while (pos >= 0);
	}

	read(code, d, d.fl.name, d.fl.pos, READ_SIZE);
	return;
};

(volatile stateful any forexObj, const (volatile stateful any data, const char error[]) -> () callback,
		volatile stateful any data, volatile stateful inputFile f, int nCurrency) -> () readCryptoLog = {
	char mess[];
	printf(mess, "Reading file %s, currency %d.\r\n", {f.name, nCurrency});
	logOutput(forexObj, mess, 6);

	forexImpl impl;
	readData d = {impl, callback, data, f, "", nCurrency};
	char err[] = convertObjToImpl(impl, forexObj, "readCryptoLog");
	if (err.csize) return finish(d, err);
	impl.data.inputValuesPerSlot = 1;

	return readCallback(d, "", 1);
};
