/* p2p manage host addresses; T16.957-T19.705; $DVS:time$ */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "../../../lib/algorithms/hashtable/hash.dpvmake"
#include "p2p.dpvmake"
#include "mailbox.dpvmh"

int STATS_PERIOD	= 300000000000;
int RECONNECT_PERIOD	=  30000000000;
int MIN_PERIOD		=  30000000000;
int HASH_TIMEOUT	=  60000000000;
int HASH_SIZE		= 256;

type hostaddr = {
        const char host[];
        const char oldhost[];
	int port;
	int oldport;
	int flags;
	int reserved;
};

/* flags */
int HOST_CONN = 1; /* connected */
int HOST_ONE  = 2; /* delete on disconnect */

type addrbook = {
        volatile hostaddr hosts[];
        volatile p2pdata data;
        volatile hashData hash;
        int time;
        int statsTime;
        int reconnectTime;
        int nConnected;
        int nBroadcasts;
        int nRequests;
        int nReqObjs;
        int nReqSkipped;
        int nAdded;
        int nRemoved;
};

(volatile stateful addrbook book, const int values[]) -> () make_conn {
	int wait_time = MIN_PERIOD;

	book.time = values[0];

	if (book.time - book.statsTime >= STATS_PERIOD) {
		book.statsTime = book.time;

		char m[];
		strcat(m, "Addrbook stats");
		strcat(m, ": hosts=");		printint(m, book.hosts.lsize, 1);
		strcat(m, ", connected=");	printint(m, book.nConnected, 1);
		strcat(m, ", broadcasts=");	printint(m, book.nBroadcasts, 1);
		strcat(m, ", requests=");	printint(m, book.nRequests, 1);
		strcat(m, ", objects=");	printint(m, book.nReqObjs, 1);
		strcat(m, ", skipped=");	printint(m, book.nReqSkipped, 1);
		strcat(m, ", added=");		printint(m, book.nAdded, 1);
		strcat(m, ", removed=");	printint(m, book.nRemoved, 1);
		strcat(m, "; hash");
		strcat(m, ": objects=");	printint(m, book.hash.nObjects, 1);
		strcat(m, ", buckets=");	printint(m, book.hash.nBuckets, 1);
		write_log(book.data, m, 7);

		if (book.data.log_level >= 10) {
			char d[];
			hashObj.dump(d, book.hash);
			write_log(book.data, d, 10);
		}
	} else if (wait_time > STATS_PERIOD - (book.time - book.statsTime))
		wait_time = STATS_PERIOD - (book.time - book.statsTime);

	if (book.time - book.reconnectTime >= RECONNECT_PERIOD) {
		book.reconnectTime = book.time;

		/* proto = TCP_code << 16 | IPv4_code << 24 */
		const int proto = 0x4060000;

		int i;
		for (i = 0; i < book.hosts.lsize; i += 1) {
			hostaddr h = book.hosts[i];
			if (!(h.flags & HOST_CONN)) {
				p2pdata data;
				objcopyto(data, book.data);
				data.thread_id = i + 1;
				data.remote_host = h.host;
				data.remote_port = h.port;
				h.oldhost = h.host;
				h.oldport = h.port;
				h.flags |= HOST_CONN;
				book.nConnected += 1;
				connectp(connection, data, h.host, proto | h.port);
			}
		}
	} else if (wait_time > RECONNECT_PERIOD - (book.time - book.reconnectTime))
		wait_time = RECONNECT_PERIOD - (book.time - book.reconnectTime);

	mrecv(book.data.func, book, book.data.mboxaddr, wait_time);
	return;
}

(volatile stateful addrbook book, any objs, int status) -> () read_mbox {
	if (status) {
		char m[];
		strcat(m, "Error ");
		printint(m, status, 1);
		strcat(m, " when received a mail in address_book, service stopped");
		write_log(book.data, m, 2);
		return;
	}

	int i;
	for (i = 0; i < objs.lsize; i += 1) {
	    p2pmess mess;
	    if (mess.type != objs.l[i].type) {
		char m[];
		strcat(m, "Dropped mailbox message of illegal format");
		write_log(book.data, m, 5);
	    } else {
		objcopyto(mess, objs.l[i]);

		int size = book.hosts.lsize;
		int found;

		char d[] = mess.data;

		if (mess.task == P2P_BROADOBJS) {
			if (d.csize < 0x80) {
				write_log(book.data, "Address book: incorrect broadcast message", 3);
				size = 0;
				found = 1;
			} else {
				char h[];
				substrcat(h, d, 0x40, 0x60);
				if (hashObj.remove(book.hash, h))
					book.nRemoved += 1;
				book.nBroadcasts += 1;
			}
		} else if (mess.task == P2P_REQOBJS) {
			int n = d.csize;
			if (!n || n & 0x1f) {
				write_log(book.data, "Address book: incorrect request message", 3);
				size = 0;
				found = 1;
			} else {
				char newd[];
				int skipped;
				int j;
				for (j = 0; j < n; j += 0x20) {
					char h[];
					substrcat(h, d, j, j + 0x20);
					any v;
					int res;
					(v, res) = hashObj.findGetValue(book.hash, h);
					if (res && v.isize == 1 && book.time - v.i[0] < HASH_TIMEOUT) {
						book.nReqSkipped += 1;
						if (!skipped && j)
							substrcat(newd, d, 0, j);
						skipped = 1;
					} else if (skipped)
						strcat(newd, h);
					int vv[];
					vv.ipush(book.time);
					if (hashObj.findAddKeyValue(book.hash, h, vv))
						book.nAdded += 1;
				}

				if (skipped)
					mess.data = newd;

				if (mess.data.csize) {
					book.nRequests += 1;
					book.nReqObjs += mess.data.csize >> 5;
				} else {
					size = 0;
					found = 1;
				}
			}
		}

		int j;
		for (j = 0; j < size; j += 1) {
			hostaddr h = book.hosts[j];
			if (h.host == mess.host && h.port == mess.port) {
				if (mess.task == P2P_ADDHOST) {
					j = size - 1;
					found = 1;
				} else if (mess.task == P2P_ADDONE) {
					if (!(h.flags & HOST_CONN)) {
						h.flags |= HOST_CONN;
						book.nConnected += 1;
					}
					j = size - 1;
					found = 1;
				} else if (mess.task == P2P_DELHOST) {
					if (h.flags & HOST_CONN)
						book.nConnected -= 1;
					if (j != size - 1)
						book.hosts[j] = book.hosts[size - 1];
					book.hosts.lpop(1);
					j = size - 1;
				} else if (mess.task == P2P_DISCONN) {
					if (h.flags & HOST_ONE) {
						if (h.flags & HOST_CONN)
							book.nConnected -= 1;
						if (j != size - 1)
							book.hosts[j] = book.hosts[size - 1];
						book.hosts.lpop(1);
					} else if (h.flags & HOST_CONN) {
						h.flags &= ~HOST_CONN;
						book.nConnected -= 1;
					}
					j = size - 1;
				} else if (mess.task == P2P_RENHOST) {
					if (found) {
						if (h.flags & HOST_CONN)
							book.nConnected -= 1;
						if (j != size - 1)
							book.hosts[j] = book.hosts[size - 1];
						book.hosts.lpop(1);
						j = size - 1;
					} else {
						if (!(h.flags & HOST_CONN)) {
							h.flags |= HOST_CONN;
							book.nConnected += 1;
						}
						h.host = mess.newhost;
						h.port = mess.newport;
						found = j + 1;
					}
				}
                        } else if (mess.task == P2P_BROADOBJS || mess.task == P2P_REQOBJS) {
				if (h.flags & HOST_CONN) {
					p2paddr addr;
					addr.module = P2P_MODULE;
					addr.service = P2P_SENDOBJ;
					addr.task_id = book.data.task_id;
					addr.host = h.oldhost;
					addr.port = h.oldport;

					msendp("", "", addr, mess);

                                        if (book.data.log_level >= 9) {
                                            char m[];
                                            strcat(m, "Sending object to host ");
                                            strcat(m, addr.host);
                                            strcat(m, ":");
                                            printint(m, addr.port, 1);
                                            strcat(m, " (");
                                            strcat(m, h.host);
                                            strcat(m, ":");
                                            printint(m, h.port, 1);
                                            strcat(m, ")");
                                            write_log(book.data, m, 9);
                                        }
				} else {
                                        if (book.data.log_level >= 9) {
                                            char m[];
                                            strcat(m, "Skipping host ");
                                            strcat(m, h.oldhost);
                                            strcat(m, ":");
                                            printint(m, h.oldport, 1);
                                            strcat(m, " (");
                                            strcat(m, h.host);
                                            strcat(m, ":");
                                            printint(m, h.port, 1);
                                            strcat(m, ")");
                                            write_log(book.data, m, 9);
                                        }
				}
			} else if (mess.task == P2P_RENHOST) {
				if (h.host == mess.newhost && h.port == mess.newport) {
					if (found) {
						book.hosts[found - 1] = book.hosts[size - 1];
						book.hosts.lpop(1);
						j = size - 1;
					} else
						found = 1;
				}
			}
		}

		if (!found) {
			if (mess.task == P2P_ADDHOST || mess.task == P2P_ADDONE) {
				hostaddr h;
				h.host = mess.host;
				h.oldhost = mess.host;
				h.port = mess.port;
				h.oldport = mess.port;
				if (mess.task == P2P_ADDONE) {
					h.flags = HOST_CONN | HOST_ONE;
					book.nConnected += 1;
				}
				book.hosts.lpush(h);
			} else if (mess.task == P2P_RENHOST) {
				hostaddr h;
				h.host = mess.newhost;
				h.oldhost = mess.host;
				h.port = mess.newport;
				h.oldport = mess.port;
				h.flags = HOST_CONN;
				book.nConnected += 1;
				book.hosts.lpush(h);
			}
		}
	    }
	}
	
	const int vars[] = {0};
	getsys(make_conn, book, vars);
	return;
}

(const stateful p2pdata d, const int values[]) -> () {
	p2pdata data;
	objcopyto(data, d);

	data.func = read_mbox;
	data.thread_id = -3;

	p2paddr addr;
	addr.module = P2P_MODULE;
	addr.service = P2P_ADDRMAN;
	addr.task_id = data.task_id;
	data.mboxaddr = addr;

	addrbook book;
	book.data = data;
	if (hashObj.initExt(book.hash, HASH_SIZE, hashFlagKeyValue))
		write_log(book.data, "Address book: hash initialization failed", 3);

	mrecv(data.func, book, data.mboxaddr, MIN_PERIOD);
	return;
}
