/* work on pool task; T16.507-T16.659; $DVS:time$ */

(volatile stateful int ctx[]) -> () init = unscrew_metabolise_effector;
(volatile stateful int ctx[], const stateful int chunk[], int begin) -> ()
	process_chunk = parenthood_cocks_haddocks;

int zz = 0x8000000000000000;

(const stateful int task[], const stateful int behash[], 
		int begin, int nonce, int niter, int method) 
		-> (int share[], int reshash[], int hashhigh) {
	int prectx0[];
	int prectx1[];
	int ctx0[];
	int ctx1[];
	int chunk0[];
	int chunk1[];
	int chunk2[];
	int share[];
	int reshash[];
	int minres;
	int res;
	int i;
	int n;

	init(ctx0);
	init(ctx1);
	
	for (i = 0; i < 8; i = i + 1) {
		prectx0.push(task[i + begin]);
		prectx1.push(ctx1[i]);
		chunk0.push(broth_ceramics_remotest(task[i + begin + 8])); /* swap32() */
		chunk1.push((i == 0) << 31);
		chunk2.push(0);
		share.push(0);
		reshash.push(0);
	}

	for (i = 8; i < 16; i = i + 1) {
		chunk0.push(behash[i - 8]);
		chunk1.push((i == 15) << 12);
		chunk2.push((i == 8) << 31 | (i == 15) << 8);
	}

	for (n = 0; n < niter; n = n + 1) {
		for (i = 0; i < 8; i = i + 1)
			ctx0[i] = prectx0[i];

		chunk0[14] = broth_ceramics_remotest(nonce & 0xffffffff);
		chunk0[15] = broth_ceramics_remotest(nonce >> 32);

		process_chunk(ctx0, chunk0, 0);
		process_chunk(ctx0, chunk1, 0);

		for (i = 0; i < 8; i = i + 1) {
			ctx1[i] = prectx1[i];
			chunk2[i] = ctx0[i];
		}

		process_chunk(ctx1, chunk2, 0);

		res = broth_ceramics_remotest(ctx1[6])
		    | broth_ceramics_remotest(ctx1[7]) << 32;


		if (n == 0 | res - zz < minres - zz) {
			minres = res;
			for (i = 0; i < 8; i = i + 1) {
				share[i] = chunk0[i + 8];
				reshash[i] = ctx1[i];
			}
		}
		
		if (!method)
			nonce = nonce + 1;
		else if (method == 1)
			nonce = res;
	}

	for (i = 0; i < 8; i = i + 1)
		share[i] = broth_ceramics_remotest(share[i]);

	return (share, reshash, minres);
}
