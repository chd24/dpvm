/* www server: read_request; T15.543-T18.884; $DVS:time$ */
	
#include "../../../lib/stdlib/stdlib.dpvmake"
#include "www_server.dpvmake"

type read_data = {
	volatile stateful www_data data;
	const any read_request;
};

(volatile stateful read_data data, const int values[]) -> () set_time {
	www_data arg = data.data;
	int status = arg.time;
	arg.time = values[0];

	char request[] = arg.request;

	/* if request is ready */
	if (strstr(request, "\r\n\r\n") >= 0) {
		int reqtype = 0;
		int index = 4;
		if (!strstr(request, "GET /")) reqtype = REQ_GET;
		else if (!strstr(request, "HEAD /")) { reqtype = REQ_HEAD; index = 5; }
		else if (!strstr(request, "POST /")) { reqtype = REQ_POST; index = 5; }
		else {
			send_headers(arg, "", 501, 0, 0);
			return;
		}

		arg.reqtype = reqtype;


		/* correct source ip if given in headers */

		char realip[];
		int newip;
		getheader(realip, request, "\nX-Real-IP: ");
		if (realip.csize > 1) {
			int ip0;
			int ip1;
			int err;
			int nextbegin;
			(ip0, ip1, err, nextbegin) = strtoip(realip, 0, realip.csize);
			if (!err) {
				arg.ipaddr0 = ip0;
				arg.ipaddr1 = ip1;
				newip = 1;
			}
		}

		if (!newip) {
			char forwardip[];
			getheader(forwardip, request, "\nX-Forwarded-For: ");
			if (forwardip.csize > 1) {
				int ip0;
				int ip1;
				int err;
				int nextbegin;
				(ip0, ip1, err, nextbegin) = strtoip(forwardip, 0, forwardip.csize);
				if (!err) {
					arg.ipaddr0 = ip0;
					arg.ipaddr1 = ip1;
				}
			}
		}


		/* read relative path from request */

		char relpath[];
		char query[];
		int i = index;
		int q = 0;
		int t;
		int j;
		int n;
		int z;

		do {
			int c = request[i];
			t = 0;
			if (c > 32) {
				i = i + 1;
				if (c == '?') q = -1;
				else if (c == '%') {
					n = 0;
					j = 2; 
					do {
						c = request[i];
						i = i + 1;
						z = strchr("0123456789ABCDEF0123456789abcdef", c);
						if (z == -1) {
							send_headers(arg, "", 404, 0, 0);
							return;
						}
						n = n << 4 | z & 0xf;
						j = j - 1;
					} while (j);
					c = n;
					if (c == '&') { c = '%'; i = i - 2; }
				}
				if (q == 0) relpath.cpush(c);
				else if (q == 1) query.cpush(c);
				else if (q == -1) q = 1;
				t = 1;
			}
		} while (t);

		/* rewrite once */
		(relpath, query) = rewrite(relpath, query);

		index += 1;
		if (i == index) {
			char relpath1[];
			strcat(relpath1, relpath);
			strcat(relpath1, arg.index);
			relpath = relpath1;
		}

		/* if path contains .. */
		if (strstr(relpath, "/..") >= 0) { 
			send_headers(arg, "", 404, 0, 0);
			return;
		}

		/* make absolute path of a file */
		char path[];
		strcat(path, arg.root);
		strcat(path, relpath);

		arg.path = path;
		arg.relpath = relpath;
		arg.query = query;
		arg.pos = -1;

		mstat(get_stat, arg, path, 0, 1);
		return;
	}

	int size = request.csize;
	int max = 1 << 12;

	/* if request is not ready */
	if (status <= 0 || size == max) {
		send_headers(arg, "", 501, 0, 0);
		return; 
	}

	input(data.read_request, arg, max - size, TIMEOUT_WEB);
	return;
}

(volatile stateful www_data arg, const char text[], int status) -> () {
	strcat(arg.request, text);

	read_data data;
	data.data = arg;
	data.read_request = code;

	if (arg.time) {
		int values[];
		values.ipush(arg.time);
		arg.time = status;
		set_time(data, values);
	} else {
		const int vars[] = {0};
		arg.time = status;
		getsys(set_time, data, vars);
	}

	return;
}
