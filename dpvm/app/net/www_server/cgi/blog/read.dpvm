/* blog internal cgi module, read file method; T18.762-T19.346; $DVS:time$ */

#include "../../../../stdlib/stdlib.dpvmake"
#include "../../../../storage/dfs/dfs.dpvmh"
#include "internal.dpvmake"

type readMessageFileData = {
	volatile stateful blogObj blog;
	const char path[];
	volatile char file[];
	int stage;
};

(int ipA0, int ipA1, int ipB0, int ipB1) -> (int res) ipaddrCmp = {
	const int z = 0x8000000000000000;
	if (ipA1 - z > ipB1 - z) return  1;
	if (ipA1 - z < ipB1 - z) return -1;
	if (ipA0 - z > ipB0 - z) return  1;
	if (ipA0 - z < ipB0 - z) return -1;
	return 0;
}

(volatile stateful any data, const char file[], const dfsFileAttributes attr, const char error[]) -> () readMessageFileCallback = {
	readMessageFileData to[];
	objcopyto(to, {data});
	readMessageFileData d = to[0];

	if (error.csize) {
		if (!d.stage && strstr(error, "not a file") >= 0) {
			d.stage = 0x10;
			d.blog.obj.methods.readMessageFile(d.blog.obj, d, code, "author.txt", d.blog.rangeBegin, d.blog.rangeEnd);
			return;
		} else if ((d.stage != 0x11 && d.stage != 0x12) || strstr(error, "not found") < 0) {
			blogOutObj.outError(d.blog, error);
			return;
		}
	}

	if (d.stage & 0x10) {
		if (file.csize)
			strcat(d.file, file);

		else {
			if (d.stage == 0x10) {
				d.blog.author = d.file;
				d.stage = 0x11;
				char f[];
				d.file = f;
				d.blog.obj.methods.readMessageFile(d.blog.obj, d, code, "header.txt", d.blog.rangeBegin, d.blog.rangeEnd);

			} else if (d.stage == 0x11) {
				d.blog.header = d.file;
				d.stage = 0x12;
				char f[];
				d.file = f;
				d.blog.obj.methods.readMessageFile(d.blog.obj, d, code, "message.txt", d.blog.rangeBegin, d.blog.rangeEnd);

			} else {
				d.blog.message = d.file;
				blogOutObj.outMessage(d.blog);
			}
		}

	} else {
		if (!d.stage) {
			d.blog.fileSize = attr.size;
			d.blog.fileMtime = attr.mtime;

			if (d.blog.fileSize < d.blog.rangeEnd)
				d.blog.rangeEnd = d.blog.fileSize;

			blogOutObj.outFileHeader(d.blog, d.path, file);
			d.stage = 1;
		}

		if (file.csize)
			outputp("", "", file);
	}

	return;
};

(volatile stateful readMessageFileData d) -> () doReadMessageFile = {
	d.blog.obj.methods.readMessageFile(d.blog.obj, d, readMessageFileCallback, d.path, d.blog.rangeBegin, d.blog.rangeEnd);
	return;
};

(volatile stateful any data, const char error[]) -> () writeMessageFileCallback = {
	readMessageFileData to[];
	objcopyto(to, {data});
	readMessageFileData d = to[0];

	if (error.csize)
		blogOutObj.outError(d.blog, error);
	else
		doReadMessageFile(d);

	return;
};

(volatile stateful readMessageFileData d) -> () readMessageFile = {
	if (d.blog.mode == BLOG_SAVE)
		blogActionObj.editMessage(d.blog, d, writeMessageFileCallback);
	else
		doReadMessageFile(d);

	return;
};

(volatile stateful any data, volatile int file[], const char error[]) -> () readFileCallback = {
	any from;
	blogObj to[];
	from.lpush(data);
	objcopyto(to, from);
	blogObj blog = to[0];

	int n = blog.currentUser, end;
	blogUser user = blog.users[n];

	if (error.csize) {
		if (user.stage == 1 && blog.mode == BLOG_MKUSER && strstr(error, "Error reading file") >= 0) {
			blogOutObj.outSpecialPage(blog);
			return;
		}
		blogOutObj.outError(blog, error);
		return;
	}

	char fileType[];

	if (user.stage == 0) {
		fileType = "env";

	} else if (user.stage == 1) {
		if (blog.mode == BLOG_MKUSER) {
			blogOutObj.outError(blog, "Error: user already exists");
			return;
		}

		/* processing environment variables for particular user */

		user.envFile = file;
		char err[] = blog.obj.methods.setupEnvironment(blog.obj, user.name, file, 0x80, file.isize);
		if (err.csize) {
			blogOutObj.outError(blog, err);
			return;
		}

		/* variables efficient only for original user (not for subscriptions) */

		if (n == 0) {

			/* redirect: redirection to another user depending on client cookie or ip address */

			char redirectStr[];
			(redirectStr, err) = blog.obj.methods.getEnvVar(blog.obj, user.name, "redirect");
			if (err.csize) {
				blogOutObj.outError(blog, err);
				return;
			}
			char redirects[][] = splitString(redirectStr, " \t\r\n");
			int i;
			for (i = 0; i < redirects.lsize; i += 1) {
				char parts[][] = splitString(redirects[i], ":"), userName[];

				/* cookie */

				if (parts.lsize == 3 && parts[0] == "cookie" || parts.lsize == 4 && parts[0] == "cookie" && parts[3] == "readonly") {
					if (parts[1] == blog.cookie)
						userName = parts[2];

				/* ip */

				} else if (parts.lsize == 3 && parts[0] == "ip" || parts.lsize == 4 && parts[0] == "ip" && parts[3] == "readonly") {
					char ips[][] = splitString(parts[1], "-");
					if (ips.lsize == 2) {
						int ipmin0, ipmin1, ipmax0, ipmax1, error0, error1, next;
						(ipmin0, ipmin1, error0, next) = strtoip(ips[0], 0, ips[0].csize);
						(ipmax0, ipmax1, error1, next) = strtoip(ips[1], 0, ips[1].csize);
						if (!error0 && !error1 &&
								ipaddrCmp(blog.ipaddr0, blog.ipaddr1, ipmin0, ipmin1) >= 0 &&
								ipaddrCmp(blog.ipaddr0, blog.ipaddr1, ipmax0, ipmax1) <= 0)
							userName = parts[2];
					}
				}

				/* redirection found */

				if (userName.csize) {
					if (parts.lsize == 4)
						blog.mode = BLOG_READONLY;

					if (userName != blog.users[0].name) {
						blog.users.lpop(1);

						blogUser u;
						u.name = userName;
						blog.users.lpush(u);

						char password[];
						(password, err) = blog.obj.methods.addUser(blog.obj, userName, password, blog.time);
						if (err.csize) return blogOutObj.outError(blog, err);

						int tmp[];
						code(blog, tmp, "");
						return;
					}
				}
			}

			/* timezone: local time offset of the user */

			char timeOffset[];
			(timeOffset, err) = blog.obj.methods.getEnvVar(blog.obj, user.name, "timezone");
			if (err.csize) {
				blogOutObj.outError(blog, err);
				return;
			}
			int timeOff, errorN, next;
			(timeOff, errorN, next) = strtoi(timeOffset, 0, timeOffset.csize, 0);
			if (!errorN && timeOff >= -12 && timeOff <= 12)
				blog.timeOffset = timeOff;


			/* perform action on blog: edit/save settings, change password, register user */

			if (blog.mode >= BLOG_SETUP && blog.mode <= BLOG_MKUSER && blog.mode != BLOG_CHANGEPWD) {
				blogOutObj.outSpecialPage(blog);
				return;
			}
		}

		/* subscribe: subscriptions to another users */

		if (blog.mode != BLOG_CHANGEPWD) {
			char subscribe[];
			(subscribe, err) = blog.obj.methods.getEnvVar(blog.obj, user.name, "subscribe");
			if (err.csize) {
				blogOutObj.outError(blog, err);
				return;
			}
			char users[][] = splitString(subscribe, ", ");
			int i;
			for (i = 0; i < users.lsize; i += 1) {
				char name[], pwd[];
				int pos = strchr(users[i], ':');
				if (pos >= 0) {
					substrcat(name, users[i], 0, pos);
					substrcat(pwd, users[i], pos + 1, users[i].csize);
				} else
					name = users[i];

				int j;
				for (j = 0; j < blog.users.lsize && blog.users[j].name != name; j += 1);
				if (j == blog.users.lsize) {
					(pwd, err) = blog.obj.methods.addUser(blog.obj, name, pwd, 0);
					if (err.csize && strstr(err, "already exists") < 0) {
						blogOutObj.outError(blog, err);
						return;
					}

					blogUser u;
					u.name = name;
					blog.users.lpush(u);
				}
			}
		}

		fileType = "blog";

	} else if (user.stage == 2 || user.stage == 3) {
		int isblog;
		if (user.stage == 2) {
			user.blogFile = file;
			isblog = 1;
			fileType = "inbox";
		} else {
			user.inboxFile = file;
			fileType = "tip";
		}

		if (blog.mode == BLOG_CHANGEPWD) {
			fileType = "tip";
			user.stage += 1;
		} else if (blog.postTime >> 32) {
			char err[];
			int index;
			if (blog.messageSet)
				;
			else if (!file.isize)
				err = "not found";
			else
				(err, index) = blog.obj.methods.setMessage(blog.obj, file, isblog << 7, file.isize, blog.postTime);

			if (!err.csize) {

				/* message found in *.blog or *.inbox file */

				char path[] = blog.fileName, f[];
				int stage;

				if (!path.csize) {

					/* real file name inside message is not given */

					if (isblog || n || blog.messageSet) {
						path = "author.txt";
						stage = 0x10;
					} else {
						user.inboxIndex = ~index;
						isblog = 1;
					}
				}

				blog.rangeEnd = -1 >> 1;
				if (!user.inboxIndex) {
					readMessageFileData d = {blog, path, f, stage};
					if (!stage) {
						char rangeStr[];
						if (getEnv(rangeStr, blog.env, "HTTP_RANGE")) {
							char ranges[][] = splitString(rangeStr, "-");
							if (ranges.lsize) {
								int e, num, next;
								(num, e, next) = strtoi(ranges[0], 0, ranges[0].csize, 10);
								if (!e && num >= 0)
									blog.rangeBegin = num;
							}
							if (ranges.lsize >= 2) {
								int e, num, next;
								(num, e, next) = strtoi(ranges[1], 0, ranges[1].csize, 10);
								if (!e && num + 1 >= blog.rangeBegin)
									blog.rangeEnd = num + 1;
							}
						}
					}
					readMessageFile(d);
					return;
				}

			} else if (strstr(err, "not found") < 0) {
				blogOutObj.outError(blog, err);
				return;
			}

			end = !isblog;

		} else {
			char err[] = blog.obj.methods.addMessages(blog.obj, file, n << 1 | isblog, isblog << 7, file.isize);
			if (err.csize) {
				blogOutObj.outError(blog, err);
				return;
			}
		}

	} else if (user.stage == 4) {
		user.tipFile = file;
		fileType = "tipbox";

		if (blog.mode == BLOG_CHANGEPWD) {
			blogOutObj.outSpecialPage(blog);
			return;
		}
	} else {
		user.tipboxFile = file;
		if (user.inboxIndex) {

			/* moving new message to regular messages database */

			int i, j, i0 = ~user.inboxIndex;

			/* copy current message from *.inbox to *.blog */

			for (i = user.blogFile.isize - 1; i >= 0x80 && !user.blogFile[i]; i -= 1);
			i = -(-i & -8);
			if (i == user.blogFile.isize) {
				for (j = 0; j < 0x80; j += 1)
					user.blogFile.ipush(0);
			}
			for (j = 0; j < 8; j += 1)
				(user.blogFile[i + j], user.inboxFile[i0 + j]) = (user.inboxFile[i0 + j], 0);

			/* copy tip from *.tipbox to *.tip */

			i = (i << 1) - 0x80, i0 <<= 1;
			if (i == user.tipFile.isize) {
				for (j = 0; j < 0x80; j += 1)
					user.tipFile.ipush(0);
			}
			for (j = 0; j < 16; j += 1)
				(user.tipFile[i + j], user.tipboxFile[i0 + j]) = (user.tipboxFile[i0 + j], 0);

			/* if *.inbox has no messages, delete it and corresponding *.tipbox */

			for (i = user.inboxFile.isize - 1; i >= 0 && !user.inboxFile[i]; i -= 1);
			if (i < 0) {
				user.inboxFile.ipop(user.inboxFile.isize);
				user.tipboxFile.ipop(user.tipboxFile.isize);
			}

			/* save all files */

			char err[] = blog.obj.methods.writeFile(blog.obj, user.name, "blog", user.blogFile);
			if (err.csize) return blogOutObj.outError(blog, err);
			err = blog.obj.methods.writeFile(blog.obj, user.name, "tip", user.tipFile);
			if (err.csize) return blogOutObj.outError(blog, err);
			err = blog.obj.methods.writeFile(blog.obj, user.name, "inbox", user.inboxFile);
			if (err.csize) return blogOutObj.outError(blog, err);
			err = blog.obj.methods.writeFile(blog.obj, user.name, "tipbox", user.tipboxFile);
			if (err.csize) return blogOutObj.outError(blog, err);

			/* go to view message */

			char f[];
			readMessageFileData d = {blog, "author.txt", f, 0x10};
			readMessageFile(d);
			return;
		}
		end = 1;
	}

	if (end) {
		n += 1;
		if (n >= blog.users.lsize) {
			if (blog.postTime >> 32) {
				blogOutObj.outError(blog, "Error: message not found");
			} else {
				blogOutObj.outList(blog);
			}
			return;
		}

		blog.currentUser = n;
		int tmp[];
		code(blog, tmp, "");
		return;
	}

	user.stage += 1;
	blog.obj.methods.readFile(blog.obj, data, code, user.name, fileType);
	return;
};
