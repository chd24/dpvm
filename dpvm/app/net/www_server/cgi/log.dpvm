/* log internal cgi module */

#include "../../../../lib/stdlib/stdlib.dpvmake"
#include "modules.dpvmake"

const char version[] = "log cgi module 0.1.1, T18.753-T20.158"; /* $DVS:time$

history:

T20.158: v. 0.1.1: change '<' and '>' symbols to html codes

T18.760: v. 0.1.0: first working version

T18.757: v. 0.0.2: pre-work version which outputs patter of html page

T18.753: v. 0.0.1: starting re-writtng the module under dpvm

*/

int STR_MAX     = 0x400;
int READ_MAX    = 0x100000;

type logObj = {
    const char query[];
    const char file[];
    const char plus[][];
    const char minus[][];
    const char tail[];
    int nlines;
    int filepos;
    int is_text;
};

(volatile stateful logObj obj, const char text[], int status) -> () fileReadCallback = {
    while (status > 0 && obj.nlines) {
        int end = status, tailsize = obj.tail.csize;

        if (text[status - 1] == '\n' && !tailsize)
            status -= 1;

        int b = status & -0x10;

        for (status -= 1; status >= b && text[status] != '\n'; status -= 1);

        if (status < b && b) {
            for (b -= 0x10; (b == 0 | text[b] == '\n' | text[b |  1] == '\n' | text[b |  2] == '\n' | text[b |  3] == '\n'
                               | text[b |  4] == '\n' | text[b |  5] == '\n' | text[b |  6] == '\n' | text[b |  7] == '\n'
                               | text[b |  8] == '\n' | text[b |  9] == '\n' | text[b | 10] == '\n' | text[b | 11] == '\n'
                               | text[b | 12] == '\n' | text[b | 13] == '\n' | text[b | 14] == '\n' | text[b | 15] == '\n')
                               == 0; b -= 0x10);

            for (status = b + 15; status >= b && text[status] != '\n'; status -= 1);
        }

        status += 1;

        char line[];
        int size = end - status + tailsize, long;
        if (size > STR_MAX) {
            size = STR_MAX >> 1;
            long = 1;
        }

        int todo = end - status;
        if (todo > size)
            todo = size;
        substrcat(line, text, status, status + todo);

        if (tailsize && todo < size) {
            todo = size - todo;
            if (todo > tailsize)
                todo = tailsize;
            substrcat(line, obj.tail, 0, todo);
        }

        if (long) {
            strcat(line, "...");

            if (tailsize < size) {
                todo = size - tailsize;
                if (todo > end - status)
                    todo = end - status;
                substrcat(line, text, end - todo, end);
            } else
                todo = 0;

            if (tailsize && todo < size) {
                todo = size - todo;
                if (todo > tailsize)
                    todo = tailsize;
                substrcat(line, obj.tail, tailsize - todo, tailsize);
            }
        }

        if (status && line.csize) {
            int i, print = 1;

            for (i = 0; print && i < obj.plus.lsize; i += 1)
                if (strstr(line, obj.plus[i]) < 0)
                    print = 0;

            for (i = 0; print && i < obj.minus.lsize; i += 1)
                if (strstr(line, obj.minus[i]) >= 0)
                    print = 0;

            if (print) {
                if (line[line.csize - 1] != '\n')
                    line.cpush('\n');

                if (obj.is_text && (strchr(line, '<') >= 0 || strchr(line, '>') >= 0)) {
			char l[];
			int linesize = line.csize;
			for (i = 0; i < linesize; i++) {
				int c = line[i];
				if (c == '<')
					strcat(l, "&lt;");
				else if (c == '>')
					strcat(l, "&gt;");
				else
					l.cpush(c);
			}
			line = l;
                }

                outputp("", "", line);
            }

            obj.nlines -= 1;

            char empty[];
            line = empty;
        }

        obj.tail = line;
    }

    if (obj.nlines && status >= 0 && obj.filepos) {
        obj.filepos -= READ_MAX;
        read(code, obj, obj.file, obj.filepos, READ_MAX);
    } else {
        char out[];
        printf(out, "</pre><hr><p><font size=2>Generated by %s</font></p></body></html>", {version});
        outputp("", "", out);
    }

    return;
};

(volatile stateful logObj obj, const any stats) -> () getStatCallback = {
    if (stats.lsize != 1) {
        outputp("", "", "Status: 404 Not found\r\n\r\n");
        return;
    }

    int mode = stats.l[0].i[4];

    /* file not exists or directory */
    if (!mode || (mode & 070000) == 040000) {
        outputp("", "", "Status: 404 Not found\r\n\r\n");
        return;
    }

    char out[];
    printf(out, "Content-Type: text/html;charset=utf-8\r\n\r\n", {});
    printf(out, "<!DOCTYPE html><html><head>
<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">
<meta name=\"generator\" content=\"%s\" >
<link href=\"/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\">
<title>Server status: %s; x%d</title>
</head><body text=\"darkblue\"><font face=\"Arial\">
<h2>Server status: %s; x%d</h2><hr><pre>",
        {version, obj.query, obj.query, obj.nlines, obj.nlines});

    outputp("", "", out);

    int filepos = stats.l[0].i[0] & -READ_MAX;
    obj.filepos = filepos;

    read(fileReadCallback, obj, obj.file, filepos, READ_MAX);
    return;
};

(const stateful char str[], char delim) -> (const char parts[][]) splitStr = {
    char parts[][];
    int begin, end = str.csize;

    while (begin < end) {
        int found = substrchr(str, begin, end, delim), next = found + 1;
        if (found < 0)
            found = end, next = end;
        char part[];
        substrcat(part, str, begin, found);
        parts.lpush(part);
        begin = next;
    }

    return parts;
};

(const char path[], const char env[][]) -> (int status) logCgi = {
    char file[], query[], scale[];

    if (!getParam(query, env, "f"))
        strcat(query, "access.log:/dsearch");

    char parts[][] = splitStr(query, ':');
    if (parts.lsize < 1 || parts.lsize > 3) {
        outputp("", "", "Status: 404 Not found\r\n\r\n");
        return 404;
    }

    if (!getParam(scale, env, "l"))
        strcat(scale, "x100");

    if (scale.csize < 2 || scale.c[0] != 'x' || scale.c[1] < '0' || scale.c[1] > '9') {
        outputp("", "", "Status: 404 Not found\r\n\r\n");
        return 404;
    }

    int nlines, error, next;
    (nlines, error, next) = strtoi(scale, 1, scale.csize, 10);
    if (error || nlines < 0) {
        outputp("", "", "Status: 404 Not found\r\n\r\n");
        return 404;
    }

    int pos = path.csize;
    while (pos && path[pos - 1] != '/') pos -= 1;
    if (pos) pos -= 1;
    while (pos && path[pos - 1] != '/') pos -= 1;
    if (pos) pos -= 1;
    while (pos && path[pos - 1] != '/') pos -= 1;

    char root[];
    substrcat(root, path, 0, pos);

    printf(file, "%slog/%s", {root, parts[0]});

    logObj obj;
    obj.query = query;
    obj.file = file;
    obj.nlines = nlines;
    obj.is_text = strstr(file, "news") < 0;
    if (parts.lsize > 2)
        obj.plus = splitStr(parts[1], ',');
    if (parts.lsize > 1)
        obj.minus = splitStr(parts[parts.lsize - 1], ',');

    mstat(getStatCallback, obj, file, 0, 1);
    return 200;
};

cgiModule logCgiModule = {
    "/cgi-bin/log.cgi",
    version,
    logCgi
};
