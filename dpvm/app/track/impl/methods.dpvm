/* track class, methods implementation, T20.105-T20.106; $DVS:time$ */
/* Generated by Class source generator, ver 0.1.2, T19.354-T20.056 */

#include "../../../lib/stdlib/stdlib.dpvmake"
#include "../../../lib/utils/utils.dpvmake"
#include "../../../tools/registry/registry.dpvmake"
#include "track.dpvmake"
#include "version.dpvmh"

int registryMask	= REGISTRY_COMPILER;	/* mask of registry applications used by track class */
int DEFAULT_TIME_LAG	= 3600000000000;	/* 1h, default time lag to split tracks */
int DEFAULT_TRACK_COLOR = 0x0000ff;
int DEFAULT_FILL_COLOR  = 0x808000;

(volatile stateful any trackObj) -> (const char error[], int flags) getFlags = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "getFlags");
	if (err.csize) return (err, 0);

	return ("", impl.data.flags);
};

(volatile stateful any trackObj, int flags) -> (const char error[]) setFlags = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "setFlags");
	if (err.csize) return err;

	impl.data.flags = flags;
	return "";
};

(volatile stateful any trackObj, int timeLag) -> (const char error[]) setTimeLag = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "setTimeLag");
	if (err.csize) return err;

	impl.data.timeLag = timeLag;
	return "";
};

(volatile stateful any trackObj, const stateful any registry) -> (const char error[]) setRegistry = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "setRegistry");
	if (err.csize) return err;

	registryData registryCopy = registryObj.copy(registry);
	err = registryObj.check(registryCopy, registryMask);
	if (err.csize) return err;

	impl.data.registry = registryCopy;
	impl.data.registrySet = 1;
	return "";
};

(volatile stateful Track tracks[], const stateful any trackObj, const stateful char pltFile[])
		-> (const char error[]) readPlt = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "readPlt");
	if (err.csize) return err;

	int size = pltFile.csize, pos, end, nline;
	for (nline = 0; pos < size; nline += 1, pos = end + 1) {
		end = substrchr(pltFile, pos, size, '\n');
		if (end < 0) end = size;
		if (nline == 0) {
			if (substrstr(pltFile, "OziExplorer Track Point File Version 2.1", pos, end) < 0)
				return mkError("Illegal plt file format", "readPlt");

		} else if (nline == 1) {
			if (substrstr(pltFile, "WGS 84", pos, end) < 0)
				return mkError("Illegal plt data format", "readPlt");

		} else if (nline == 4) {
			Track t;
			any obj;
			scanf(obj, "%d ,%d ,%d ,%s ,%d ,%d ,%d ,%d", pltFile, pos, end);
			if (obj.lsize) {
				char names[][];
				pushObject(obj.l[0], names);
				t.name = names[0];
			} else
				t.name = "defaultTrack";
			t.trackColor = obj.isize >= 3 ? obj.i[2] : DEFAULT_TRACK_COLOR;
			t.fillColor  = obj.isize >= 7 ? obj.i[6] : DEFAULT_FILL_COLOR;
			tracks.lpush(t);

		} else if (nline >= 6) {
			any obj;
			scanf(obj, "%f,%f,%d,%f,%f", pltFile, pos, end);
			if (!obj.isize || obj.fsize != 4) {
				char mess[];
				printf(mess, "illegal line %d in plt file", {nline});
				return mkError(mess, "readPlt");
			}
			int time = (obj.f[3] - (35065 - 26*365 - 6)) * 24*60*60*1000000000;
			trackPoint p = {time, obj.i[0], obj.f[0], obj.f[1], obj.f[2]};
			tracks[tracks.lsize - 1].points.lpush(p);
		}
	}

	if (nline < 6)
		return mkError("empty track", "readPlt");

	return "";
};

(volatile stateful Track tracks[], const stateful any trackObj, const stateful Track track)
		-> (const char error[]) splitTrack = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "splitTrack");
	if (err.csize) return err;

	int timeLag = impl.data.timeLag ? impl.data.timeLag : DEFAULT_TIME_LAG, i, size = track.points.lsize, day, n;
	for (i = 0; i < size; i += 1) {
		trackPoint p = track.points[i];
		if (!i || p.time >= track.points[i - 1].time + timeLag) {
			char name[];
			strftime(name, "%Y-%m-%d", p.time, 0);
			int newDay = p.time / (24*60*60*1000000000);
			if (newDay == day) {
				n += 1;
				printf(name, "-%d", {n});
			} else
				day = newDay, n = 0;

			Track t = {name};
			t.trackColor = track.trackColor;
			t.fillColor = track.fillColor;
			tracks.lpush(t);
		}
		tracks[tracks.lsize - 1].points.lpush(p);
	}

	return "";
};

(volatile stateful char pltFile[], const stateful any trackObj, const stateful Track track)
		-> (const char error[]) savePlt = {
	trackImpl impl;
	char err[] = convertObjToImpl(impl, trackObj, "savePlt");
	if (err.csize) return err;

	printf(pltFile, "OziExplorer Track Point File Version 2.1\
WGS 84\
Altitude is in Feet\
Reserved 3\
0,2,%d,%s ,0,0,2,%d\
%d\r\n",
		{track.name, track.trackColor, track.fillColor, track.points.lsize});

	int i, size = track.points.lsize;
	for (i = 0; i < size; i += 1) {
		trackPoint p = track.points[i];
		char stime[];
		strftime(stime, "%d-%b-%Y, %H:%M:%S", p.time, impl.data.registry.timeZone);
		printf(pltFile, "%11.6f,%11.6f,%d,%7.1f,%13.7f, %s\r\n",
			{stime, p.isBreak, p.latitude, p.longitude, p.altitude,
			p.time * 1.0 / (24*60*60*1000000000) + 35065 - 26*365 - 6});
	}

	return "";
};

trackMethods trackMethodsImpl = {
	version,
	getFlags,
	setFlags,
	setTimeLag,
	setRegistry,
	readPlt,
	splitTrack,
	savePlt,
	dump
};
